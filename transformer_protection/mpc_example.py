# -*- coding: utf-8 -*-
"""MPC_example

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nan7en5Qfs9JD2fl6Vs-yJPpiCAlfC_x
"""

# # Run this cell if you are using Colab
# install required dependencies

#!pip install -q pyomo
#!wget -N -q "https://ampl.com/dl/open/ipopt/ipopt-linux64.zip"
#!unzip -o -q ipopt-linux64
#ipopt_executable = '/content/ipopt'
#
## !python -m pip install gurobipy
#!pip install -i https://pypi.gurobi.com gurobipy
#gurobi_executable = '/content/gurobi'
#
#!apt-get install -y -qq glpk-utils
#
#!pip install cplex

import cplex

#!pip install baron

import baron

import numpy as np
import matplotlib.pyplot as plt
import cvxpy as cp
import pyomo.environ as pyo
import scipy.linalg
from scipy.integrate import solve_ivp
from math import *
from pyomo.environ import Piecewise
from pyomo.environ import value

import gurobipy as gp
from gurobipy import GRB

dt = 0.25 # 15 mins

"""## Problem setup:

**Dynamics**:
* Scalar states representing SOC (?)
* 2 dimensional input - $[u_{chg}, u_{V2G}]$ (?)

**Objective**:

**Constraints**:

The below function solves a Constrained Finite Time Optimal Control problem.

* A, B: dynamics matrices

* Q: state penalty matrix in objective
* R: input penalty matrix in objective
* P: final state penalty matrix in objective

* N: CFTOC horizon (less than entire time horizon)
* x0: initial state - changes every iteration
* uL, uU: bounds on input
* d: binary driving or not
"""

from collections import UserList
from pyomo.core.base.indexed_component import rule_result_substituter
def solve_cftoc(A, B, P, Q, R_chg, R_v2g, N, x0, d, soc_min, uL, uU):

    model = pyo.ConcreteModel()
    model.N = N
    model.nx = 1 #np.size(A, 0)
    model.nu = 1 #np.size(B, 1)
    model.reg = 1


    # length of finite optimization problem:
    model.tIDX = pyo.Set( initialize= range(model.N+1), ordered=True )
    model.xIDX = pyo.Set( initialize= range(model.nx), ordered=True )
    model.uIDX = pyo.Set( initialize= range(model.nu), ordered=True )


    # these are 2d arrays:
    model.A = A
    model.B = B
    model.Q = Q
    model.P = P
    # model.R_v2g = R_v2g
    # model.R_chg = R_chg

    # model.xref = xref
    # model.uref = uref

    # Create state and input variables trajectory:
    model.x = pyo.Var(model.xIDX, model.tIDX) #SOC
    model.u_v2g = pyo.Var(model.uIDX, model.tIDX, bounds=(-uU,uL))


    model.c = pyo.Var(model.xIDX, model.tIDX, within=pyo.Binary)
    model.d = pyo.Var(model.xIDX, model.tIDX, within=pyo.Binary)
    model.v2g = pyo.Var(model.xIDX, model.tIDX, within=pyo.Binary)

    breakpts = [0,0.2, .8,1]
    values  = [1,0,0,1]
    #model.piecewise_fxn = Piecewise(breakpts, values, Input = model.x, Output = model.x)


    #Objective:
    def objective_rule(model):
        costX = 0.0
        costU = 0.0
        costTerminal = 0.0
        # for t in model.tIDX:
        #     for i in model.xIDX:
        #         for j in model.xIDX:
        #             if t < model.N:
        #                 costX += (model.x[i, t] - model.xref[i, t]) * model.Q[i, j] * (model.x[j, t] - model.xref[j, t])

        # def f(model, x):
        #   if (x)>.8:
        #     return model.reg*(x - 0.8)
        #   elif x<0.2:
        #     return model.reg*(0.2 - x)

          # if value(model.x[j, t])<.2:
          #   lower_lim = .2 - model.x[j, t]
          # else:
          #   lower_lim = 0


        #input costs
        for t in model.tIDX:
            for i in model.uIDX:
                for j in model.uIDX:
                    if t < model.N:
                        model.R_v2g = R_v2g[t]
                        model.R_chg = R_chg[t]

                        # costU += (model.u_v2g[i, t]) *model.R_v2g * (model.u_v2g[j, t])
                        # costU += 6.6**2 * (model.c[i, t]) * model.R_chg * (model.c[j, t])
                        costU += (model.R_v2g + np.random.normal(model.R_v2g, .02/16*t))  * (model.u_v2g[j, t])
                        costU += 6.6 * model.R_chg * (model.c[j, t])
                        # costX += -0.1*pyo.log(0.85-model.x[j, t]) -0.1*pyo.log(model.x[j, t] - 0.15)
                        costX += (model.x[j, t] - 0.5)**2
                        # model.piecewise = pyo.Piecewise(model.x, model.z, pw_pts = [0, 0.2, 0.8, 1],f_rule = f(model, model.x[j, t]) )

                        #model.z_constraint =



                        #costX += model.reg  *(max(model.x[j, t]-.80, 0) + max(.20-model.x[j, t], 0))
                        #costX += model.reg  *(max(model.x[j, t]-.80, 0) + max(.20-model.x[j, t], 0))
                        # costX += model.reg  *(upper_lim + lower_lim)

                        #costX += model.reg * model.piecewise_fxn(model.x[j, t])


        # for i in model.xIDX:
        #     for j in model.xIDX:
        #         costTerminal += (model.x[i, model.N] - model.xref[i, model.N]) * model.P[i, j] * (model.x[j, model.N] - model.xref[j, model.N])
        return costU + costX

    model.cost = pyo.Objective(rule = objective_rule, sense=pyo.minimize)

    # Constraints:
    def equality_const_rule(model, i, t):
        return model.x[i, t+1] - (sum(model.A[i, j] * model.x[j, t] for j in model.xIDX)
                               +  (model.B[i, 0] * model.c[0, t]) + (model.B[i, 1] * model.u_v2g[0, t]) + (model.B[i, 2] * model.d[0, t]) ) == 0.0 if t < model.N else pyo.Constraint.Skip

    #Dynamics constraint
    model.equality_constraints = pyo.Constraint(model.xIDX, model.tIDX, rule=equality_const_rule)

    #Initial state constraint
    model.init_const1 = pyo.Constraint(expr = model.x[0, 0] == x0)

    #State constraints (SOC min and max)
    x1U = 1
    # x1L = 0
    model.state_limit1 = pyo.Constraint(model.tIDX, rule=lambda model, t: model.x[0, t] <= x1U
                                   if t < N else pyo.Constraint.Skip)
    model.state_limit2 = pyo.Constraint(model.tIDX, rule=lambda model, t: soc_min[t] <= model.x[0, t]
                                    if t < N else pyo.Constraint.Skip)

    # Binary sum constraint
    model.binary_sum = pyo.Constraint(model.tIDX, rule=lambda model, t: model.c[0, t] + model.d[0, t] - model.u_v2g[0, t]/100 <= 1 if t < N else pyo.Constraint.Skip)
    model.drive_limit = pyo.Constraint(model.tIDX, rule=lambda model, t: model.d[0, t] - d[t] == 0 if t < N else pyo.Constraint.Skip)


    solver = pyo.SolverFactory('ipopt') #, executable='/usr/bin/glpsol'
    # solver = pyo.SolverFactory('glpk', executable='/usr/bin/glpsol')

    # solver.options['NonConvex'] = 2
    results = solver.solve(model)

    if str(results.solver.termination_condition) == "optimal":
        feas = True
    else:
        feas = False

    xOpt = np.asarray([[model.x[i,t]() for i in model.xIDX] for t in model.tIDX]).T
    uOpt_v2g = np.asarray([model.u_v2g[:,t]() for t in model.tIDX]).T
    uOpt_chg = np.asarray([model.c[:,t]() for t in model.tIDX]).T

    JOpt = model.cost()

    return [model, feas, xOpt, uOpt_v2g, uOpt_chg, JOpt]

"""### MPC Simulation"""

#data vector:
#LMP, charge_price, SOC_min, drive_times
data=np.zeros((480,4))

#define drive_times
for i in range(28, 480, 96):
  data[i,3]=1
  data[i+1,3]=1
for i in range(64, 480, 96):
  data[i,3]=1
  data[i+1,3]=1

#define SOC_min
for i in range(27, 480, 96):
  data[i,2]=.25

for i in range(63, 480, 96):
  data[i,2]=.25

#define charging prices
#stanford charging
for i in range(28, 480, 96):
  data[i:i+36,1]=1/6.6

#home off-peak charging
for i in range(0, 480, 96):
  data[i:i+28,1]=.24

#home peak charging
for i in range(64, 480, 96):
  data[i:i+20,1]=.56

#home partial peak
for i in range(84, 480, 96):
  data[i:i+12,1]=.45




#print(data)
plt.plot(data[:,2])
plt.show()



"""#### LMP Raw Data"""

## LMP data import
## Dates: Jan 7th - Jan 11th

lmp_data = np.array([41.45513, 41.45513, 41.45513, 41.45513, 50.60781, 50.60781,
       50.60781, 50.60781, 52.92343, 52.92343, 52.92343, 52.92343,
       47.22771, 47.22771, 47.22771, 47.22771, 44.87053, 44.87053,
       44.87053, 44.87053, 41.16888, 41.16888, 41.16888, 41.16888,
       36.64384, 36.64384, 36.64384, 36.64384, 35.27399, 35.27399,
       35.27399, 35.27399, 36.18826, 36.18826, 36.18826, 36.18826,
       34.78879, 34.78879, 34.78879, 34.78879, 33.64945, 33.64945,
       33.64945, 33.64945, 34.85848, 34.85848, 34.85848, 34.85848,
       36.77719, 36.77719, 36.77719, 36.77719, 41.25397, 41.25397,
       41.25397, 41.25397, 51.67247, 51.67247, 51.67247, 51.67247,
       59.93034, 59.93034, 59.93034, 59.93034, 47.81135, 47.81135,
       47.81135, 47.81135, 47.26041, 47.26041, 47.26041, 47.26041,
       43.23347, 43.23347, 43.23347, 43.23347, 40.84247, 40.84247,
       40.84247, 40.84247, 37.25221, 37.25221, 37.25221, 37.25221,
       37.12063, 37.12063, 37.12063, 37.12063, 36.6039 , 36.6039 ,
       36.6039 , 36.6039 , 42.41436, 42.41436, 42.41436, 42.41436,
       58.32435, 58.32435, 58.32435, 58.32435, 90.41919, 90.41919,
       90.41919, 90.41919, 73.74262, 73.74262, 73.74262, 73.74262,
       67.88963, 67.88963, 67.88963, 67.88963, 57.67635, 57.67635,
       57.67635, 57.67635, 48.3719 , 48.3719 , 48.3719 , 48.3719 ,
       45.07883, 45.07883, 45.07883, 45.07883, 40.39727, 40.39727,
       40.39727, 40.39727, 36.52873, 36.52873, 36.52873, 36.52873,
       35.74226, 35.74226, 35.74226, 35.74226, 34.24404, 34.24404,
       34.24404, 34.24404, 34.79655, 34.79655, 34.79655, 34.79655,
       37.05346, 37.05346, 37.05346, 37.05346, 41.83363, 41.83363,
       41.83363, 41.83363, 53.31083, 53.31083, 53.31083, 53.31083,
       70.45637, 70.45637, 70.45637, 70.45637, 52.42591, 52.42591,
       52.42591, 52.42591, 47.28253, 47.28253, 47.28253, 47.28253,
       43.44738, 43.44738, 43.44738, 43.44738, 41.16611, 41.16611,
       41.16611, 41.16611, 35.43672, 35.43672, 35.43672, 35.43672,
       38.11085, 38.11085, 38.11085, 38.11085, 40.90183, 40.90183,
       40.90183, 40.90183, 43.96166, 43.96166, 43.96166, 43.96166,
       63.56677, 63.56677, 63.56677, 63.56677, 81.07857, 81.07857,
       81.07857, 81.07857, 66.0227 , 66.0227 , 66.0227 , 66.0227 ,
       64.88937, 64.88937, 64.88937, 64.88937, 54.36366, 54.36366,
       54.36366, 54.36366, 49.57312, 49.57312, 49.57312, 49.57312,
       42.63927, 42.63927, 42.63927, 42.63927, 38.74521, 38.74521,
       38.74521, 38.74521, 37.90096, 37.90096, 37.90096, 37.90096,
       37.42086, 37.42086, 37.42086, 37.42086, 35.51213, 35.51213,
       35.51213, 35.51213, 36.29183, 36.29183, 36.29183, 36.29183,
       38.40615, 38.40615, 38.40615, 38.40615, 42.71479, 42.71479,
       42.71479, 42.71479, 51.25563, 51.25563, 51.25563, 51.25563,
       54.16933, 54.16933, 54.16933, 54.16933, 40.09386, 40.09386,
       40.09386, 40.09386, 37.31372, 37.31372, 37.31372, 37.31372,
       35.78034, 35.78034, 35.78034, 35.78034, 34.20743, 34.20743,
       34.20743, 34.20743, 35.72586, 35.72586, 35.72586, 35.72586,
       35.24103, 35.24103, 35.24103, 35.24103, 36.83714, 36.83714,
       36.83714, 36.83714, 40.68342, 40.68342, 40.68342, 40.68342,
       55.48113, 55.48113, 55.48113, 55.48113, 74.88754, 74.88754,
       74.88754, 74.88754, 69.26319, 69.26319, 69.26319, 69.26319,
       62.702  , 62.702  , 62.702  , 62.702  , 54.52263, 54.52263,
       54.52263, 54.52263, 49.70503, 49.70503, 49.70503, 49.70503,
       41.54795, 41.54795, 41.54795, 41.54795, 38.7185 , 38.7185 ,
       38.7185 , 38.7185 , 34.35788, 34.35788, 34.35788, 34.35788,
       33.80452, 33.80452, 33.80452, 33.80452, 32.36612, 32.36612,
       32.36612, 32.36612, 32.67973, 32.67973, 32.67973, 32.67973,
       34.47404, 34.47404, 34.47404, 34.47404, 39.72919, 39.72919,
       39.72919, 39.72919, 52.4744 , 52.4744 , 52.4744 , 52.4744 ,
       51.48832, 51.48832, 51.48832, 51.48832, 38.3314 , 38.3314 ,
       38.3314 , 38.3314 , 34.91448, 34.91448, 34.91448, 34.91448,
       35.0084 , 35.0084 , 35.0084 , 35.0084 , 35.30264, 35.30264,
       35.30264, 35.30264, 32.62529, 32.62529, 32.62529, 32.62529,
       33.89516, 33.89516, 33.89516, 33.89516, 35.86752, 35.86752,
       35.86752, 35.86752, 35.93882, 35.93882, 35.93882, 35.93882,
       50.0833 , 50.0833 , 50.0833 , 50.0833 , 70.71095, 70.71095,
       70.71095, 70.71095, 68.29267, 68.29267, 68.29267, 68.29267,
       60.64473, 60.64473, 60.64473, 60.64473, 52.42091, 52.42091,
       52.42091, 52.42091, 44.38158, 44.38158, 44.38158, 44.38158,
       40.28624, 40.28624, 40.28624, 40.28624, 37.0622 , 37.0622 ,
       37.0622 , 37.0622 , 35.87443, 35.87443, 35.87443, 35.87443,
       34.30319, 34.30319, 34.30319, 34.30319, 33.39148, 33.39148,
       33.39148, 33.39148, 32.71204, 32.71204, 32.71204, 32.71204,
       36.02244, 36.02244, 36.02244, 36.02244, 41.94245, 41.94245,
       41.94245, 41.94245, 53.58464, 53.58464, 53.58464, 53.58464,
       51.38237, 51.38237, 51.38237, 51.38237, 39.15958, 39.15958,
       39.15958, 39.15958, 35.68034, 35.68034, 35.68034, 35.68034,
       34.74514, 34.74514, 34.74514, 34.74514, 32.97655, 32.97655,
       32.97655, 32.97655, 34.77756, 34.77756, 34.77756, 34.77756,
       34.70903, 34.70903, 34.70903, 34.70903, 34.48989, 34.48989,
       34.48989, 34.48989, 38.5788 , 38.5788 , 38.5788 , 38.5788 ])/1000

"""#### LMP Processed Data"""

plt.plot(lmp_data)
print(np.mean(lmp_data))
print(np.std(lmp_data))

data[:, 0] = lmp_data
data

"""## Simulation Code"""

from pyomo.environ import *

A = np.ones(1).reshape((1, 1))
eta_c = 0.94
eta_v2g = 0.81
dt = 0.25
Q = 62 #kWh corresponds to 226 miles range
B = dt*np.array([6.6*eta_c/Q, eta_v2g/Q, -10.97/Q]).reshape((1, 3))

nx = np.size(A, 0)  # number of states
nu = np.size(B, 1)  # number of inputs

Lsim = 480 - 16 #15 mins intervals over 5 days
N = 16
#V2G input limits
uL = 0
uU = 100

r_chg = 1
r_v2g = 1

#x0 = np.ones((1,1))
x0=1
P = 0
xk=x0

umpc_closedloop = np.zeros((1, 3))
ym = []
#xk_open = np.zeros((nx, N+1))    # to plot open-loop trajectories
xk_closed = np.zeros((nx, Lsim+1)) # to plot closed-loop trajectories
xk_closed[:, 0] = x0      # set initial value of closed-loop trajectory
# xk = x0.reshape(2,1)
fig = plt.figure(figsize=(12, 8))
ax1 = fig.add_subplot(221)
ax2 = fig.add_subplot(222)

# simulate MPC controller
for t in range(Lsim):

    for k in range(N+1):
      R_chg = []
      R_v2g = []
      for m in range(N + 1):
        R_chg.append(data[t+m, 1])
        R_v2g.append(10*data[t+m, 0])
    d = data[t:t+N+1, 3]
    soc_min = data[t:t+N+1, 2]

    # Solve MPC
    #print(xk)
    [model, feas, xOpt, uOpt_v2g, uOpt_c, JOpt] = solve_cftoc(A, B, P, Q, R_chg, R_v2g, N, xk, d, soc_min, uL, uU)
    if feas == False:
        print('The problem is infeasible')
    # U = uOpt[0,0]
    #print('uopt shape')
    #print(uOpt_c.shape)
    uOpt=np.array([uOpt_c[0,0], uOpt_v2g[0,0], data[t,3]])
    #print('uOpt:', uOpt)
    umpc_closedloop = np.vstack((umpc_closedloop, uOpt))
    if t%50==0:
      print(t)

    # if (t < (Lsim-N)):
    # # plot open-loop trajectories

    #     for m in range(N):
    #         xk_open[:, m+1] = A @ xk_open[:, m] + B @ uOpt[:, m]

    #     line1 = ax1.plot(range(t, t+len(ref_preview) ), xk_open[0,:], 'o-', color='b')
    #     line2 = ax2.plot(range(t, t+len(ref_preview) ), xk_open[1,:], 'o-', color='b')

    # Plant model update
    C = 1

    ym.append(xk)
    #print(B.shape)
    #print(np.asarray(uOpt).shape)

    Bu= B @ np.asarray(uOpt).reshape(3,1)
    xk = float(A * xk + Bu[0,0])
    xk_closed[0, t]=xk

##################################################################################################################
##################################################################################################################
# plot closed-loop trajectories
line11 = ax1.plot(range(Lsim), xk_closed[0, :Lsim], 'o-', color='r')
# ax1.legend([line1[0], line11[0]], ['open-loop trajectory', 'closed-loop trajectory'])
# ax1.set_ylabel('x1')
line22 = ax2.plot(range(Lsim), xk_closed[1, :Lsim], 'o-', color='r')
ax2.legend([line2[0], line22[0]], ['open-loop trajectory', 'closed-loop trajectory'])
ax2.set_ylabel('x2')
# plt.show()

# Plot Results
ax12 = fig.add_subplot(223)
ax22 = fig.add_subplot(224)
ax12.step(range(len(umpc_closedloop)), umpc_closedloop,'r')
ax12.legend(['u'])
ax22.step(range(len(ym)), np.asarray(ym).reshape(Lsim,), 'r')
ax22.step(range(len(ref)), ref, 'b--')
ax22.legend([line2[0], line22[0]], ['r', 'y'])
plt.tight_layout()
plt.show()

plt.figure(figsize=(15, 5))
plt.plot(umpc_closedloop[:, 0])
plt.title('Charging Control Input')
plt.plot(data[:, 1])
plt.legend(['Control Input', 'Charging Price'])

plt.figure(figsize=(10, 5))
plt.plot(data[:, 1])
plt.plot(10*data[:, 0])
plt.legend(['Charging Price', 'LMP Scaled'])
plt.ylabel('Price ($/kWh)')

plt.figure(figsize=(15, 5))
plt.plot(umpc_closedloop[:, 1])
plt.title('V2G Control Input')

plt.figure(figsize=(15, 5))
plt.plot(umpc_closedloop[:, 2])
plt.title('Drive')

plt.figure(figsize=(25, 5))
plt.scatter(np.arange(0, 50), umpc_closedloop[:50, 2])
plt.scatter(np.arange(0, 50),  -1*umpc_closedloop[:50, 1]/100)
plt.scatter(np.arange(0, 50), umpc_closedloop[:50, 0])
plt.legend(['Drive', 'V2G scaled', 'Charging'])

"""

*   Charging + Charging price
*   V2G + LMP
*   All 3 graphs overlaid
* SOC

"""

plt.figure(figsize=(10, 5))
line11 = plt.plot(range(Lsim), xk_closed[0, :Lsim], 'o-', color='r')
plt.ylabel('SOC')

plt.plot(umpc_closedloop[:100, 0])

from scipy.interpolate import interp1d

f_chg = interp1d(np.arange(0, 100), umpc_closedloop[:100, 0], kind='zero', axis=0)
f_v2g = interp1d(np.arange(0, 100), umpc_closedloop[:100, 1], kind='zero', axis=0)
f_drive = interp1d(np.arange(0, 100), umpc_closedloop[:100, 2], kind='zero', axis=0)
f_chg_price = interp1d(np.arange(0, 100), data[:100, 1], kind='zero', axis=0)
f_lmp = interp1d(np.arange(0, 100), data[:100, 0], kind='zero', axis=0)

plt.figure(figsize=(15, 5))

plt.plot(np.linspace(0, 96, 1000), f_chg(np.linspace(0, 96, 1000)))
plt.plot(np.linspace(0, 96, 1000), -1*f_v2g(np.linspace(0, 96, 1000))/100)
plt.plot(np.linspace(0, 96, 1000), f_drive(np.linspace(0, 96, 1000)))
plt.legend(['Charge Control Input', 'V2G Scaled Control Input', 'Drive'])

fig, ax1 = plt.subplots(figsize=(15, 5))
c1 = 'blue'
c2 = 'red'
ax1.plot(np.linspace(0, 96, 1000), 6.6*f_chg(np.linspace(0, 96, 1000)), color=c1)
plt.title('Charging Control Input')
ax1.set_ylabel('Charging Control Input (kW)', color=c1)
ax2.tick_params(axis='y', labelcolor=c1)

ax2 = ax1.twinx()
ax2.plot(np.linspace(0, 96, 1000), f_chg_price(np.linspace(0, 96, 1000)), color=c2)
ax2.set_ylabel('Charging Price ($/kWh)', color=c2)
ax2.tick_params(axis='y', labelcolor=c2)
# plt.legend(['Control Input', 'Charging Price'])

# plt.figure(figsize=(15, 5))
# plt.plot(np.linspace(0, 96, 1000), -1*f_v2g(np.linspace(0, 96, 1000))/100)
# plt.title('Vehicle-to-Grid Control Input')
# plt.plot(np.linspace(0, 96, 1000), 10*f_lmp(np.linspace(0, 96, 1000)))
# plt.legend(['Scaled V2G Control Input', 'Scaled LMP'])


fig, ax1 = plt.subplots(figsize=(15, 5))
c1 = 'orange'
c2 = 'purple'
ax1.plot(np.linspace(0, 96, 1000), f_v2g(np.linspace(0, 96, 1000)), color=c1)
plt.title('Vehicle-to-Grid Control Input')
ax1.set_ylabel('V2G Control Input (kW)', color=c1)
ax2.tick_params(axis='y', labelcolor=c1)

ax2 = ax1.twinx()
ax2.plot(np.linspace(0, 96, 1000), f_lmp(np.linspace(0, 96, 1000)), color=c2)
ax2.set_ylabel('LMP ($/kWh)', color=c2)
ax2.tick_params(axis='y', labelcolor=c2)
# plt.legend(['Control Input', 'Charging Price'])

plt.figure(figsize=(15, 5))

plt.plot(np.linspace(0, 96, 1000), f_chg(np.linspace(0, 96, 1000)))
plt.plot(np.linspace(0, 96, 1000), f_v2g(np.linspace(0, 96, 1000)))
plt.plot(np.linspace(0, 96, 1000), f_drive(np.linspace(0, 96, 1000)))
plt.legend(['Charge Control Input', 'V2G Control Input', 'Drive'])

