// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: battery_manager.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_battery_5fmanager_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_battery_5fmanager_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_battery_5fmanager_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_battery_5fmanager_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_battery_5fmanager_2eproto;
namespace bosproto {
class AdminResponse;
struct AdminResponseDefaultTypeInternal;
extern AdminResponseDefaultTypeInternal _AdminResponse_default_instance_;
class Admin_Command;
struct Admin_CommandDefaultTypeInternal;
extern Admin_CommandDefaultTypeInternal _Admin_Command_default_instance_;
class Aggregate_Battery;
struct Aggregate_BatteryDefaultTypeInternal;
extern Aggregate_BatteryDefaultTypeInternal _Aggregate_Battery_default_instance_;
class Dynamic_Battery;
struct Dynamic_BatteryDefaultTypeInternal;
extern Dynamic_BatteryDefaultTypeInternal _Dynamic_Battery_default_instance_;
class Partition_Battery;
struct Partition_BatteryDefaultTypeInternal;
extern Partition_BatteryDefaultTypeInternal _Partition_Battery_default_instance_;
class Physical_Battery;
struct Physical_BatteryDefaultTypeInternal;
extern Physical_BatteryDefaultTypeInternal _Physical_Battery_default_instance_;
class Scale;
struct ScaleDefaultTypeInternal;
extern ScaleDefaultTypeInternal _Scale_default_instance_;
}  // namespace bosproto
PROTOBUF_NAMESPACE_OPEN
template<> ::bosproto::AdminResponse* Arena::CreateMaybeMessage<::bosproto::AdminResponse>(Arena*);
template<> ::bosproto::Admin_Command* Arena::CreateMaybeMessage<::bosproto::Admin_Command>(Arena*);
template<> ::bosproto::Aggregate_Battery* Arena::CreateMaybeMessage<::bosproto::Aggregate_Battery>(Arena*);
template<> ::bosproto::Dynamic_Battery* Arena::CreateMaybeMessage<::bosproto::Dynamic_Battery>(Arena*);
template<> ::bosproto::Partition_Battery* Arena::CreateMaybeMessage<::bosproto::Partition_Battery>(Arena*);
template<> ::bosproto::Physical_Battery* Arena::CreateMaybeMessage<::bosproto::Physical_Battery>(Arena*);
template<> ::bosproto::Scale* Arena::CreateMaybeMessage<::bosproto::Scale>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosproto {

enum Refresh : int {
  LAZY = 0,
  ACTIVE = 1,
  Refresh_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Refresh_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Refresh_IsValid(int value);
constexpr Refresh Refresh_MIN = LAZY;
constexpr Refresh Refresh_MAX = ACTIVE;
constexpr int Refresh_ARRAYSIZE = Refresh_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Refresh_descriptor();
template<typename T>
inline const std::string& Refresh_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Refresh>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Refresh_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Refresh_descriptor(), enum_t_value);
}
inline bool Refresh_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Refresh* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Refresh>(
    Refresh_descriptor(), name, value);
}
enum Policy : int {
  PROPORTIONAL = 0,
  TRANCHED = 1,
  RESERVED = 2,
  Policy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Policy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Policy_IsValid(int value);
constexpr Policy Policy_MIN = PROPORTIONAL;
constexpr Policy Policy_MAX = RESERVED;
constexpr int Policy_ARRAYSIZE = Policy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Policy_descriptor();
template<typename T>
inline const std::string& Policy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Policy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Policy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Policy_descriptor(), enum_t_value);
}
inline bool Policy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Policy>(
    Policy_descriptor(), name, value);
}
enum Command_Options : int {
  Create_Physical = 0,
  Create_Aggregate = 1,
  Create_Partition = 2,
  Create_Dynamic = 3,
  Shutdown = 4,
  Command_Options_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Command_Options_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Command_Options_IsValid(int value);
constexpr Command_Options Command_Options_MIN = Create_Physical;
constexpr Command_Options Command_Options_MAX = Shutdown;
constexpr int Command_Options_ARRAYSIZE = Command_Options_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_Options_descriptor();
template<typename T>
inline const std::string& Command_Options_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command_Options>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_Options_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_Options_descriptor(), enum_t_value);
}
inline bool Command_Options_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command_Options* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command_Options>(
    Command_Options_descriptor(), name, value);
}
// ===================================================================

class Scale final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.Scale) */ {
 public:
  inline Scale() : Scale(nullptr) {}
  ~Scale() override;
  explicit PROTOBUF_CONSTEXPR Scale(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Scale(const Scale& from);
  Scale(Scale&& from) noexcept
    : Scale() {
    *this = ::std::move(from);
  }

  inline Scale& operator=(const Scale& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scale& operator=(Scale&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scale& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scale* internal_default_instance() {
    return reinterpret_cast<const Scale*>(
               &_Scale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Scale& a, Scale& b) {
    a.Swap(&b);
  }
  inline void Swap(Scale* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scale* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scale* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Scale>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Scale& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Scale& from) {
    Scale::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scale* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.Scale";
  }
  protected:
  explicit Scale(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChargeProportionFieldNumber = 1,
    kCapacityProportionFieldNumber = 2,
  };
  // double charge_proportion = 1;
  void clear_charge_proportion();
  double charge_proportion() const;
  void set_charge_proportion(double value);
  private:
  double _internal_charge_proportion() const;
  void _internal_set_charge_proportion(double value);
  public:

  // double capacity_proportion = 2;
  void clear_capacity_proportion();
  double capacity_proportion() const;
  void set_capacity_proportion(double value);
  private:
  double _internal_capacity_proportion() const;
  void _internal_set_capacity_proportion(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosproto.Scale)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double charge_proportion_;
    double capacity_proportion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Physical_Battery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.Physical_Battery) */ {
 public:
  inline Physical_Battery() : Physical_Battery(nullptr) {}
  ~Physical_Battery() override;
  explicit PROTOBUF_CONSTEXPR Physical_Battery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Physical_Battery(const Physical_Battery& from);
  Physical_Battery(Physical_Battery&& from) noexcept
    : Physical_Battery() {
    *this = ::std::move(from);
  }

  inline Physical_Battery& operator=(const Physical_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Physical_Battery& operator=(Physical_Battery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Physical_Battery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Physical_Battery* internal_default_instance() {
    return reinterpret_cast<const Physical_Battery*>(
               &_Physical_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Physical_Battery& a, Physical_Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(Physical_Battery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Physical_Battery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Physical_Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Physical_Battery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Physical_Battery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Physical_Battery& from) {
    Physical_Battery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Physical_Battery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.Physical_Battery";
  }
  protected:
  explicit Physical_Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryNameFieldNumber = 1,
    kMaxStalenessFieldNumber = 2,
    kRefreshModeFieldNumber = 3,
  };
  // string batteryName = 1;
  void clear_batteryname();
  const std::string& batteryname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batteryname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batteryname();
  PROTOBUF_NODISCARD std::string* release_batteryname();
  void set_allocated_batteryname(std::string* batteryname);
  private:
  const std::string& _internal_batteryname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batteryname(const std::string& value);
  std::string* _internal_mutable_batteryname();
  public:

  // optional uint64 max_staleness = 2;
  bool has_max_staleness() const;
  private:
  bool _internal_has_max_staleness() const;
  public:
  void clear_max_staleness();
  uint64_t max_staleness() const;
  void set_max_staleness(uint64_t value);
  private:
  uint64_t _internal_max_staleness() const;
  void _internal_set_max_staleness(uint64_t value);
  public:

  // optional .bosproto.Refresh refresh_mode = 3;
  bool has_refresh_mode() const;
  private:
  bool _internal_has_refresh_mode() const;
  public:
  void clear_refresh_mode();
  ::bosproto::Refresh refresh_mode() const;
  void set_refresh_mode(::bosproto::Refresh value);
  private:
  ::bosproto::Refresh _internal_refresh_mode() const;
  void _internal_set_refresh_mode(::bosproto::Refresh value);
  public:

  // @@protoc_insertion_point(class_scope:bosproto.Physical_Battery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batteryname_;
    uint64_t max_staleness_;
    int refresh_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Dynamic_Battery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.Dynamic_Battery) */ {
 public:
  inline Dynamic_Battery() : Dynamic_Battery(nullptr) {}
  ~Dynamic_Battery() override;
  explicit PROTOBUF_CONSTEXPR Dynamic_Battery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dynamic_Battery(const Dynamic_Battery& from);
  Dynamic_Battery(Dynamic_Battery&& from) noexcept
    : Dynamic_Battery() {
    *this = ::std::move(from);
  }

  inline Dynamic_Battery& operator=(const Dynamic_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dynamic_Battery& operator=(Dynamic_Battery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dynamic_Battery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dynamic_Battery* internal_default_instance() {
    return reinterpret_cast<const Dynamic_Battery*>(
               &_Dynamic_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Dynamic_Battery& a, Dynamic_Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(Dynamic_Battery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dynamic_Battery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dynamic_Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dynamic_Battery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dynamic_Battery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dynamic_Battery& from) {
    Dynamic_Battery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dynamic_Battery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.Dynamic_Battery";
  }
  protected:
  explicit Dynamic_Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 6,
    kBatteryNameFieldNumber = 1,
    kRefreshFuncFieldNumber = 2,
    kDestructorFuncFieldNumber = 3,
    kConstructorFuncFieldNumber = 4,
    kSetCurrentFuncFieldNumber = 5,
    kMaxStalenessFieldNumber = 7,
    kRefreshModeFieldNumber = 8,
  };
  // repeated string arguments = 6;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // string batteryName = 1;
  void clear_batteryname();
  const std::string& batteryname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batteryname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batteryname();
  PROTOBUF_NODISCARD std::string* release_batteryname();
  void set_allocated_batteryname(std::string* batteryname);
  private:
  const std::string& _internal_batteryname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batteryname(const std::string& value);
  std::string* _internal_mutable_batteryname();
  public:

  // string refresh_func = 2;
  void clear_refresh_func();
  const std::string& refresh_func() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_func(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_func();
  PROTOBUF_NODISCARD std::string* release_refresh_func();
  void set_allocated_refresh_func(std::string* refresh_func);
  private:
  const std::string& _internal_refresh_func() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_func(const std::string& value);
  std::string* _internal_mutable_refresh_func();
  public:

  // string destructor_func = 3;
  void clear_destructor_func();
  const std::string& destructor_func() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destructor_func(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destructor_func();
  PROTOBUF_NODISCARD std::string* release_destructor_func();
  void set_allocated_destructor_func(std::string* destructor_func);
  private:
  const std::string& _internal_destructor_func() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destructor_func(const std::string& value);
  std::string* _internal_mutable_destructor_func();
  public:

  // string constructor_func = 4;
  void clear_constructor_func();
  const std::string& constructor_func() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_constructor_func(ArgT0&& arg0, ArgT... args);
  std::string* mutable_constructor_func();
  PROTOBUF_NODISCARD std::string* release_constructor_func();
  void set_allocated_constructor_func(std::string* constructor_func);
  private:
  const std::string& _internal_constructor_func() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_constructor_func(const std::string& value);
  std::string* _internal_mutable_constructor_func();
  public:

  // string set_current_func = 5;
  void clear_set_current_func();
  const std::string& set_current_func() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_current_func(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_current_func();
  PROTOBUF_NODISCARD std::string* release_set_current_func();
  void set_allocated_set_current_func(std::string* set_current_func);
  private:
  const std::string& _internal_set_current_func() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_current_func(const std::string& value);
  std::string* _internal_mutable_set_current_func();
  public:

  // optional uint64 max_staleness = 7;
  bool has_max_staleness() const;
  private:
  bool _internal_has_max_staleness() const;
  public:
  void clear_max_staleness();
  uint64_t max_staleness() const;
  void set_max_staleness(uint64_t value);
  private:
  uint64_t _internal_max_staleness() const;
  void _internal_set_max_staleness(uint64_t value);
  public:

  // optional .bosproto.Refresh refresh_mode = 8;
  bool has_refresh_mode() const;
  private:
  bool _internal_has_refresh_mode() const;
  public:
  void clear_refresh_mode();
  ::bosproto::Refresh refresh_mode() const;
  void set_refresh_mode(::bosproto::Refresh value);
  private:
  ::bosproto::Refresh _internal_refresh_mode() const;
  void _internal_set_refresh_mode(::bosproto::Refresh value);
  public:

  // @@protoc_insertion_point(class_scope:bosproto.Dynamic_Battery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batteryname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_func_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destructor_func_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr constructor_func_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_current_func_;
    uint64_t max_staleness_;
    int refresh_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Aggregate_Battery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.Aggregate_Battery) */ {
 public:
  inline Aggregate_Battery() : Aggregate_Battery(nullptr) {}
  ~Aggregate_Battery() override;
  explicit PROTOBUF_CONSTEXPR Aggregate_Battery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggregate_Battery(const Aggregate_Battery& from);
  Aggregate_Battery(Aggregate_Battery&& from) noexcept
    : Aggregate_Battery() {
    *this = ::std::move(from);
  }

  inline Aggregate_Battery& operator=(const Aggregate_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregate_Battery& operator=(Aggregate_Battery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregate_Battery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregate_Battery* internal_default_instance() {
    return reinterpret_cast<const Aggregate_Battery*>(
               &_Aggregate_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Aggregate_Battery& a, Aggregate_Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregate_Battery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregate_Battery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregate_Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregate_Battery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggregate_Battery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Aggregate_Battery& from) {
    Aggregate_Battery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggregate_Battery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.Aggregate_Battery";
  }
  protected:
  explicit Aggregate_Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentNamesFieldNumber = 2,
    kBatteryNameFieldNumber = 1,
    kMaxStalenessFieldNumber = 3,
    kRefreshModeFieldNumber = 4,
  };
  // repeated string parentNames = 2;
  int parentnames_size() const;
  private:
  int _internal_parentnames_size() const;
  public:
  void clear_parentnames();
  const std::string& parentnames(int index) const;
  std::string* mutable_parentnames(int index);
  void set_parentnames(int index, const std::string& value);
  void set_parentnames(int index, std::string&& value);
  void set_parentnames(int index, const char* value);
  void set_parentnames(int index, const char* value, size_t size);
  std::string* add_parentnames();
  void add_parentnames(const std::string& value);
  void add_parentnames(std::string&& value);
  void add_parentnames(const char* value);
  void add_parentnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& parentnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_parentnames();
  private:
  const std::string& _internal_parentnames(int index) const;
  std::string* _internal_add_parentnames();
  public:

  // string batteryName = 1;
  void clear_batteryname();
  const std::string& batteryname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batteryname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batteryname();
  PROTOBUF_NODISCARD std::string* release_batteryname();
  void set_allocated_batteryname(std::string* batteryname);
  private:
  const std::string& _internal_batteryname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batteryname(const std::string& value);
  std::string* _internal_mutable_batteryname();
  public:

  // optional uint64 max_staleness = 3;
  bool has_max_staleness() const;
  private:
  bool _internal_has_max_staleness() const;
  public:
  void clear_max_staleness();
  uint64_t max_staleness() const;
  void set_max_staleness(uint64_t value);
  private:
  uint64_t _internal_max_staleness() const;
  void _internal_set_max_staleness(uint64_t value);
  public:

  // optional .bosproto.Refresh refresh_mode = 4;
  bool has_refresh_mode() const;
  private:
  bool _internal_has_refresh_mode() const;
  public:
  void clear_refresh_mode();
  ::bosproto::Refresh refresh_mode() const;
  void set_refresh_mode(::bosproto::Refresh value);
  private:
  ::bosproto::Refresh _internal_refresh_mode() const;
  void _internal_set_refresh_mode(::bosproto::Refresh value);
  public:

  // @@protoc_insertion_point(class_scope:bosproto.Aggregate_Battery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> parentnames_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batteryname_;
    uint64_t max_staleness_;
    int refresh_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Partition_Battery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.Partition_Battery) */ {
 public:
  inline Partition_Battery() : Partition_Battery(nullptr) {}
  ~Partition_Battery() override;
  explicit PROTOBUF_CONSTEXPR Partition_Battery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Partition_Battery(const Partition_Battery& from);
  Partition_Battery(Partition_Battery&& from) noexcept
    : Partition_Battery() {
    *this = ::std::move(from);
  }

  inline Partition_Battery& operator=(const Partition_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition_Battery& operator=(Partition_Battery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Partition_Battery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Partition_Battery* internal_default_instance() {
    return reinterpret_cast<const Partition_Battery*>(
               &_Partition_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Partition_Battery& a, Partition_Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(Partition_Battery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Partition_Battery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Partition_Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Partition_Battery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Partition_Battery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Partition_Battery& from) {
    Partition_Battery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition_Battery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.Partition_Battery";
  }
  protected:
  explicit Partition_Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 3,
    kScalesFieldNumber = 4,
    kMaxStalenessesFieldNumber = 5,
    kRefreshModesFieldNumber = 6,
    kSourceNameFieldNumber = 1,
    kPolicyFieldNumber = 2,
  };
  // repeated string names = 3;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // repeated .bosproto.Scale scales = 4;
  int scales_size() const;
  private:
  int _internal_scales_size() const;
  public:
  void clear_scales();
  ::bosproto::Scale* mutable_scales(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosproto::Scale >*
      mutable_scales();
  private:
  const ::bosproto::Scale& _internal_scales(int index) const;
  ::bosproto::Scale* _internal_add_scales();
  public:
  const ::bosproto::Scale& scales(int index) const;
  ::bosproto::Scale* add_scales();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosproto::Scale >&
      scales() const;

  // repeated uint64 max_stalenesses = 5;
  int max_stalenesses_size() const;
  private:
  int _internal_max_stalenesses_size() const;
  public:
  void clear_max_stalenesses();
  private:
  uint64_t _internal_max_stalenesses(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_max_stalenesses() const;
  void _internal_add_max_stalenesses(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_max_stalenesses();
  public:
  uint64_t max_stalenesses(int index) const;
  void set_max_stalenesses(int index, uint64_t value);
  void add_max_stalenesses(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      max_stalenesses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_max_stalenesses();

  // repeated .bosproto.Refresh refresh_modes = 6;
  int refresh_modes_size() const;
  private:
  int _internal_refresh_modes_size() const;
  public:
  void clear_refresh_modes();
  private:
  ::bosproto::Refresh _internal_refresh_modes(int index) const;
  void _internal_add_refresh_modes(::bosproto::Refresh value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_refresh_modes();
  public:
  ::bosproto::Refresh refresh_modes(int index) const;
  void set_refresh_modes(int index, ::bosproto::Refresh value);
  void add_refresh_modes(::bosproto::Refresh value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& refresh_modes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_refresh_modes();

  // string sourceName = 1;
  void clear_sourcename();
  const std::string& sourcename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcename();
  PROTOBUF_NODISCARD std::string* release_sourcename();
  void set_allocated_sourcename(std::string* sourcename);
  private:
  const std::string& _internal_sourcename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcename(const std::string& value);
  std::string* _internal_mutable_sourcename();
  public:

  // .bosproto.Policy policy = 2;
  void clear_policy();
  ::bosproto::Policy policy() const;
  void set_policy(::bosproto::Policy value);
  private:
  ::bosproto::Policy _internal_policy() const;
  void _internal_set_policy(::bosproto::Policy value);
  public:

  // @@protoc_insertion_point(class_scope:bosproto.Partition_Battery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosproto::Scale > scales_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > max_stalenesses_;
    mutable std::atomic<int> _max_stalenesses_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> refresh_modes_;
    mutable std::atomic<int> _refresh_modes_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcename_;
    int policy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Admin_Command final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.Admin_Command) */ {
 public:
  inline Admin_Command() : Admin_Command(nullptr) {}
  ~Admin_Command() override;
  explicit PROTOBUF_CONSTEXPR Admin_Command(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Admin_Command(const Admin_Command& from);
  Admin_Command(Admin_Command&& from) noexcept
    : Admin_Command() {
    *this = ::std::move(from);
  }

  inline Admin_Command& operator=(const Admin_Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Admin_Command& operator=(Admin_Command&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Admin_Command& default_instance() {
    return *internal_default_instance();
  }
  enum CommandParametersCase {
    kPhysicalBattery = 2,
    kAggregateBattery = 3,
    kPartitionBattery = 4,
    kDynamicBattery = 5,
    COMMAND_PARAMETERS_NOT_SET = 0,
  };

  static inline const Admin_Command* internal_default_instance() {
    return reinterpret_cast<const Admin_Command*>(
               &_Admin_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Admin_Command& a, Admin_Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Admin_Command* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Admin_Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Admin_Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Admin_Command>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Admin_Command& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Admin_Command& from) {
    Admin_Command::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Admin_Command* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.Admin_Command";
  }
  protected:
  explicit Admin_Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandOptionsFieldNumber = 1,
    kPhysicalBatteryFieldNumber = 2,
    kAggregateBatteryFieldNumber = 3,
    kPartitionBatteryFieldNumber = 4,
    kDynamicBatteryFieldNumber = 5,
  };
  // .bosproto.Command_Options command_options = 1;
  void clear_command_options();
  ::bosproto::Command_Options command_options() const;
  void set_command_options(::bosproto::Command_Options value);
  private:
  ::bosproto::Command_Options _internal_command_options() const;
  void _internal_set_command_options(::bosproto::Command_Options value);
  public:

  // .bosproto.Physical_Battery physical_battery = 2;
  bool has_physical_battery() const;
  private:
  bool _internal_has_physical_battery() const;
  public:
  void clear_physical_battery();
  const ::bosproto::Physical_Battery& physical_battery() const;
  PROTOBUF_NODISCARD ::bosproto::Physical_Battery* release_physical_battery();
  ::bosproto::Physical_Battery* mutable_physical_battery();
  void set_allocated_physical_battery(::bosproto::Physical_Battery* physical_battery);
  private:
  const ::bosproto::Physical_Battery& _internal_physical_battery() const;
  ::bosproto::Physical_Battery* _internal_mutable_physical_battery();
  public:
  void unsafe_arena_set_allocated_physical_battery(
      ::bosproto::Physical_Battery* physical_battery);
  ::bosproto::Physical_Battery* unsafe_arena_release_physical_battery();

  // .bosproto.Aggregate_Battery aggregate_battery = 3;
  bool has_aggregate_battery() const;
  private:
  bool _internal_has_aggregate_battery() const;
  public:
  void clear_aggregate_battery();
  const ::bosproto::Aggregate_Battery& aggregate_battery() const;
  PROTOBUF_NODISCARD ::bosproto::Aggregate_Battery* release_aggregate_battery();
  ::bosproto::Aggregate_Battery* mutable_aggregate_battery();
  void set_allocated_aggregate_battery(::bosproto::Aggregate_Battery* aggregate_battery);
  private:
  const ::bosproto::Aggregate_Battery& _internal_aggregate_battery() const;
  ::bosproto::Aggregate_Battery* _internal_mutable_aggregate_battery();
  public:
  void unsafe_arena_set_allocated_aggregate_battery(
      ::bosproto::Aggregate_Battery* aggregate_battery);
  ::bosproto::Aggregate_Battery* unsafe_arena_release_aggregate_battery();

  // .bosproto.Partition_Battery partition_battery = 4;
  bool has_partition_battery() const;
  private:
  bool _internal_has_partition_battery() const;
  public:
  void clear_partition_battery();
  const ::bosproto::Partition_Battery& partition_battery() const;
  PROTOBUF_NODISCARD ::bosproto::Partition_Battery* release_partition_battery();
  ::bosproto::Partition_Battery* mutable_partition_battery();
  void set_allocated_partition_battery(::bosproto::Partition_Battery* partition_battery);
  private:
  const ::bosproto::Partition_Battery& _internal_partition_battery() const;
  ::bosproto::Partition_Battery* _internal_mutable_partition_battery();
  public:
  void unsafe_arena_set_allocated_partition_battery(
      ::bosproto::Partition_Battery* partition_battery);
  ::bosproto::Partition_Battery* unsafe_arena_release_partition_battery();

  // .bosproto.Dynamic_Battery dynamic_battery = 5;
  bool has_dynamic_battery() const;
  private:
  bool _internal_has_dynamic_battery() const;
  public:
  void clear_dynamic_battery();
  const ::bosproto::Dynamic_Battery& dynamic_battery() const;
  PROTOBUF_NODISCARD ::bosproto::Dynamic_Battery* release_dynamic_battery();
  ::bosproto::Dynamic_Battery* mutable_dynamic_battery();
  void set_allocated_dynamic_battery(::bosproto::Dynamic_Battery* dynamic_battery);
  private:
  const ::bosproto::Dynamic_Battery& _internal_dynamic_battery() const;
  ::bosproto::Dynamic_Battery* _internal_mutable_dynamic_battery();
  public:
  void unsafe_arena_set_allocated_dynamic_battery(
      ::bosproto::Dynamic_Battery* dynamic_battery);
  ::bosproto::Dynamic_Battery* unsafe_arena_release_dynamic_battery();

  void clear_command_parameters();
  CommandParametersCase command_parameters_case() const;
  // @@protoc_insertion_point(class_scope:bosproto.Admin_Command)
 private:
  class _Internal;
  void set_has_physical_battery();
  void set_has_aggregate_battery();
  void set_has_partition_battery();
  void set_has_dynamic_battery();

  inline bool has_command_parameters() const;
  inline void clear_has_command_parameters();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int command_options_;
    union CommandParametersUnion {
      constexpr CommandParametersUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::bosproto::Physical_Battery* physical_battery_;
      ::bosproto::Aggregate_Battery* aggregate_battery_;
      ::bosproto::Partition_Battery* partition_battery_;
      ::bosproto::Dynamic_Battery* dynamic_battery_;
    } command_parameters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class AdminResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosproto.AdminResponse) */ {
 public:
  inline AdminResponse() : AdminResponse(nullptr) {}
  ~AdminResponse() override;
  explicit PROTOBUF_CONSTEXPR AdminResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminResponse(const AdminResponse& from);
  AdminResponse(AdminResponse&& from) noexcept
    : AdminResponse() {
    *this = ::std::move(from);
  }

  inline AdminResponse& operator=(const AdminResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminResponse& operator=(AdminResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ReturnValueCase {
    kSuccessMessage = 2,
    kFailureMessage = 3,
    RETURN_VALUE_NOT_SET = 0,
  };

  static inline const AdminResponse* internal_default_instance() {
    return reinterpret_cast<const AdminResponse*>(
               &_AdminResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AdminResponse& a, AdminResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminResponse& from) {
    AdminResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosproto.AdminResponse";
  }
  protected:
  explicit AdminResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnCodeFieldNumber = 1,
    kSuccessMessageFieldNumber = 2,
    kFailureMessageFieldNumber = 3,
  };
  // int64 return_code = 1;
  void clear_return_code();
  int64_t return_code() const;
  void set_return_code(int64_t value);
  private:
  int64_t _internal_return_code() const;
  void _internal_set_return_code(int64_t value);
  public:

  // string success_message = 2;
  bool has_success_message() const;
  private:
  bool _internal_has_success_message() const;
  public:
  void clear_success_message();
  const std::string& success_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success_message();
  PROTOBUF_NODISCARD std::string* release_success_message();
  void set_allocated_success_message(std::string* success_message);
  private:
  const std::string& _internal_success_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success_message(const std::string& value);
  std::string* _internal_mutable_success_message();
  public:

  // string failure_message = 3;
  bool has_failure_message() const;
  private:
  bool _internal_has_failure_message() const;
  public:
  void clear_failure_message();
  const std::string& failure_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failure_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failure_message();
  PROTOBUF_NODISCARD std::string* release_failure_message();
  void set_allocated_failure_message(std::string* failure_message);
  private:
  const std::string& _internal_failure_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_message(const std::string& value);
  std::string* _internal_mutable_failure_message();
  public:

  void clear_return_value();
  ReturnValueCase return_value_case() const;
  // @@protoc_insertion_point(class_scope:bosproto.AdminResponse)
 private:
  class _Internal;
  void set_has_success_message();
  void set_has_failure_message();

  inline bool has_return_value() const;
  inline void clear_has_return_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t return_code_;
    union ReturnValueUnion {
      constexpr ReturnValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_message_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_message_;
    } return_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_battery_5fmanager_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Scale

// double charge_proportion = 1;
inline void Scale::clear_charge_proportion() {
  _impl_.charge_proportion_ = 0;
}
inline double Scale::_internal_charge_proportion() const {
  return _impl_.charge_proportion_;
}
inline double Scale::charge_proportion() const {
  // @@protoc_insertion_point(field_get:bosproto.Scale.charge_proportion)
  return _internal_charge_proportion();
}
inline void Scale::_internal_set_charge_proportion(double value) {
  
  _impl_.charge_proportion_ = value;
}
inline void Scale::set_charge_proportion(double value) {
  _internal_set_charge_proportion(value);
  // @@protoc_insertion_point(field_set:bosproto.Scale.charge_proportion)
}

// double capacity_proportion = 2;
inline void Scale::clear_capacity_proportion() {
  _impl_.capacity_proportion_ = 0;
}
inline double Scale::_internal_capacity_proportion() const {
  return _impl_.capacity_proportion_;
}
inline double Scale::capacity_proportion() const {
  // @@protoc_insertion_point(field_get:bosproto.Scale.capacity_proportion)
  return _internal_capacity_proportion();
}
inline void Scale::_internal_set_capacity_proportion(double value) {
  
  _impl_.capacity_proportion_ = value;
}
inline void Scale::set_capacity_proportion(double value) {
  _internal_set_capacity_proportion(value);
  // @@protoc_insertion_point(field_set:bosproto.Scale.capacity_proportion)
}

// -------------------------------------------------------------------

// Physical_Battery

// string batteryName = 1;
inline void Physical_Battery::clear_batteryname() {
  _impl_.batteryname_.ClearToEmpty();
}
inline const std::string& Physical_Battery::batteryname() const {
  // @@protoc_insertion_point(field_get:bosproto.Physical_Battery.batteryName)
  return _internal_batteryname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Physical_Battery::set_batteryname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batteryname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Physical_Battery.batteryName)
}
inline std::string* Physical_Battery::mutable_batteryname() {
  std::string* _s = _internal_mutable_batteryname();
  // @@protoc_insertion_point(field_mutable:bosproto.Physical_Battery.batteryName)
  return _s;
}
inline const std::string& Physical_Battery::_internal_batteryname() const {
  return _impl_.batteryname_.Get();
}
inline void Physical_Battery::_internal_set_batteryname(const std::string& value) {
  
  _impl_.batteryname_.Set(value, GetArenaForAllocation());
}
inline std::string* Physical_Battery::_internal_mutable_batteryname() {
  
  return _impl_.batteryname_.Mutable(GetArenaForAllocation());
}
inline std::string* Physical_Battery::release_batteryname() {
  // @@protoc_insertion_point(field_release:bosproto.Physical_Battery.batteryName)
  return _impl_.batteryname_.Release();
}
inline void Physical_Battery::set_allocated_batteryname(std::string* batteryname) {
  if (batteryname != nullptr) {
    
  } else {
    
  }
  _impl_.batteryname_.SetAllocated(batteryname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batteryname_.IsDefault()) {
    _impl_.batteryname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Physical_Battery.batteryName)
}

// optional uint64 max_staleness = 2;
inline bool Physical_Battery::_internal_has_max_staleness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Physical_Battery::has_max_staleness() const {
  return _internal_has_max_staleness();
}
inline void Physical_Battery::clear_max_staleness() {
  _impl_.max_staleness_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Physical_Battery::_internal_max_staleness() const {
  return _impl_.max_staleness_;
}
inline uint64_t Physical_Battery::max_staleness() const {
  // @@protoc_insertion_point(field_get:bosproto.Physical_Battery.max_staleness)
  return _internal_max_staleness();
}
inline void Physical_Battery::_internal_set_max_staleness(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_staleness_ = value;
}
inline void Physical_Battery::set_max_staleness(uint64_t value) {
  _internal_set_max_staleness(value);
  // @@protoc_insertion_point(field_set:bosproto.Physical_Battery.max_staleness)
}

// optional .bosproto.Refresh refresh_mode = 3;
inline bool Physical_Battery::_internal_has_refresh_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Physical_Battery::has_refresh_mode() const {
  return _internal_has_refresh_mode();
}
inline void Physical_Battery::clear_refresh_mode() {
  _impl_.refresh_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::bosproto::Refresh Physical_Battery::_internal_refresh_mode() const {
  return static_cast< ::bosproto::Refresh >(_impl_.refresh_mode_);
}
inline ::bosproto::Refresh Physical_Battery::refresh_mode() const {
  // @@protoc_insertion_point(field_get:bosproto.Physical_Battery.refresh_mode)
  return _internal_refresh_mode();
}
inline void Physical_Battery::_internal_set_refresh_mode(::bosproto::Refresh value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.refresh_mode_ = value;
}
inline void Physical_Battery::set_refresh_mode(::bosproto::Refresh value) {
  _internal_set_refresh_mode(value);
  // @@protoc_insertion_point(field_set:bosproto.Physical_Battery.refresh_mode)
}

// -------------------------------------------------------------------

// Dynamic_Battery

// string batteryName = 1;
inline void Dynamic_Battery::clear_batteryname() {
  _impl_.batteryname_.ClearToEmpty();
}
inline const std::string& Dynamic_Battery::batteryname() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.batteryName)
  return _internal_batteryname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dynamic_Battery::set_batteryname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batteryname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.batteryName)
}
inline std::string* Dynamic_Battery::mutable_batteryname() {
  std::string* _s = _internal_mutable_batteryname();
  // @@protoc_insertion_point(field_mutable:bosproto.Dynamic_Battery.batteryName)
  return _s;
}
inline const std::string& Dynamic_Battery::_internal_batteryname() const {
  return _impl_.batteryname_.Get();
}
inline void Dynamic_Battery::_internal_set_batteryname(const std::string& value) {
  
  _impl_.batteryname_.Set(value, GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::_internal_mutable_batteryname() {
  
  return _impl_.batteryname_.Mutable(GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::release_batteryname() {
  // @@protoc_insertion_point(field_release:bosproto.Dynamic_Battery.batteryName)
  return _impl_.batteryname_.Release();
}
inline void Dynamic_Battery::set_allocated_batteryname(std::string* batteryname) {
  if (batteryname != nullptr) {
    
  } else {
    
  }
  _impl_.batteryname_.SetAllocated(batteryname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batteryname_.IsDefault()) {
    _impl_.batteryname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Dynamic_Battery.batteryName)
}

// string refresh_func = 2;
inline void Dynamic_Battery::clear_refresh_func() {
  _impl_.refresh_func_.ClearToEmpty();
}
inline const std::string& Dynamic_Battery::refresh_func() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.refresh_func)
  return _internal_refresh_func();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dynamic_Battery::set_refresh_func(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_func_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.refresh_func)
}
inline std::string* Dynamic_Battery::mutable_refresh_func() {
  std::string* _s = _internal_mutable_refresh_func();
  // @@protoc_insertion_point(field_mutable:bosproto.Dynamic_Battery.refresh_func)
  return _s;
}
inline const std::string& Dynamic_Battery::_internal_refresh_func() const {
  return _impl_.refresh_func_.Get();
}
inline void Dynamic_Battery::_internal_set_refresh_func(const std::string& value) {
  
  _impl_.refresh_func_.Set(value, GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::_internal_mutable_refresh_func() {
  
  return _impl_.refresh_func_.Mutable(GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::release_refresh_func() {
  // @@protoc_insertion_point(field_release:bosproto.Dynamic_Battery.refresh_func)
  return _impl_.refresh_func_.Release();
}
inline void Dynamic_Battery::set_allocated_refresh_func(std::string* refresh_func) {
  if (refresh_func != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_func_.SetAllocated(refresh_func, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_func_.IsDefault()) {
    _impl_.refresh_func_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Dynamic_Battery.refresh_func)
}

// string destructor_func = 3;
inline void Dynamic_Battery::clear_destructor_func() {
  _impl_.destructor_func_.ClearToEmpty();
}
inline const std::string& Dynamic_Battery::destructor_func() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.destructor_func)
  return _internal_destructor_func();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dynamic_Battery::set_destructor_func(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destructor_func_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.destructor_func)
}
inline std::string* Dynamic_Battery::mutable_destructor_func() {
  std::string* _s = _internal_mutable_destructor_func();
  // @@protoc_insertion_point(field_mutable:bosproto.Dynamic_Battery.destructor_func)
  return _s;
}
inline const std::string& Dynamic_Battery::_internal_destructor_func() const {
  return _impl_.destructor_func_.Get();
}
inline void Dynamic_Battery::_internal_set_destructor_func(const std::string& value) {
  
  _impl_.destructor_func_.Set(value, GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::_internal_mutable_destructor_func() {
  
  return _impl_.destructor_func_.Mutable(GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::release_destructor_func() {
  // @@protoc_insertion_point(field_release:bosproto.Dynamic_Battery.destructor_func)
  return _impl_.destructor_func_.Release();
}
inline void Dynamic_Battery::set_allocated_destructor_func(std::string* destructor_func) {
  if (destructor_func != nullptr) {
    
  } else {
    
  }
  _impl_.destructor_func_.SetAllocated(destructor_func, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destructor_func_.IsDefault()) {
    _impl_.destructor_func_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Dynamic_Battery.destructor_func)
}

// string constructor_func = 4;
inline void Dynamic_Battery::clear_constructor_func() {
  _impl_.constructor_func_.ClearToEmpty();
}
inline const std::string& Dynamic_Battery::constructor_func() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.constructor_func)
  return _internal_constructor_func();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dynamic_Battery::set_constructor_func(ArgT0&& arg0, ArgT... args) {
 
 _impl_.constructor_func_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.constructor_func)
}
inline std::string* Dynamic_Battery::mutable_constructor_func() {
  std::string* _s = _internal_mutable_constructor_func();
  // @@protoc_insertion_point(field_mutable:bosproto.Dynamic_Battery.constructor_func)
  return _s;
}
inline const std::string& Dynamic_Battery::_internal_constructor_func() const {
  return _impl_.constructor_func_.Get();
}
inline void Dynamic_Battery::_internal_set_constructor_func(const std::string& value) {
  
  _impl_.constructor_func_.Set(value, GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::_internal_mutable_constructor_func() {
  
  return _impl_.constructor_func_.Mutable(GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::release_constructor_func() {
  // @@protoc_insertion_point(field_release:bosproto.Dynamic_Battery.constructor_func)
  return _impl_.constructor_func_.Release();
}
inline void Dynamic_Battery::set_allocated_constructor_func(std::string* constructor_func) {
  if (constructor_func != nullptr) {
    
  } else {
    
  }
  _impl_.constructor_func_.SetAllocated(constructor_func, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.constructor_func_.IsDefault()) {
    _impl_.constructor_func_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Dynamic_Battery.constructor_func)
}

// string set_current_func = 5;
inline void Dynamic_Battery::clear_set_current_func() {
  _impl_.set_current_func_.ClearToEmpty();
}
inline const std::string& Dynamic_Battery::set_current_func() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.set_current_func)
  return _internal_set_current_func();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dynamic_Battery::set_set_current_func(ArgT0&& arg0, ArgT... args) {
 
 _impl_.set_current_func_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.set_current_func)
}
inline std::string* Dynamic_Battery::mutable_set_current_func() {
  std::string* _s = _internal_mutable_set_current_func();
  // @@protoc_insertion_point(field_mutable:bosproto.Dynamic_Battery.set_current_func)
  return _s;
}
inline const std::string& Dynamic_Battery::_internal_set_current_func() const {
  return _impl_.set_current_func_.Get();
}
inline void Dynamic_Battery::_internal_set_set_current_func(const std::string& value) {
  
  _impl_.set_current_func_.Set(value, GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::_internal_mutable_set_current_func() {
  
  return _impl_.set_current_func_.Mutable(GetArenaForAllocation());
}
inline std::string* Dynamic_Battery::release_set_current_func() {
  // @@protoc_insertion_point(field_release:bosproto.Dynamic_Battery.set_current_func)
  return _impl_.set_current_func_.Release();
}
inline void Dynamic_Battery::set_allocated_set_current_func(std::string* set_current_func) {
  if (set_current_func != nullptr) {
    
  } else {
    
  }
  _impl_.set_current_func_.SetAllocated(set_current_func, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.set_current_func_.IsDefault()) {
    _impl_.set_current_func_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Dynamic_Battery.set_current_func)
}

// repeated string arguments = 6;
inline int Dynamic_Battery::_internal_arguments_size() const {
  return _impl_.arguments_.size();
}
inline int Dynamic_Battery::arguments_size() const {
  return _internal_arguments_size();
}
inline void Dynamic_Battery::clear_arguments() {
  _impl_.arguments_.Clear();
}
inline std::string* Dynamic_Battery::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:bosproto.Dynamic_Battery.arguments)
  return _s;
}
inline const std::string& Dynamic_Battery::_internal_arguments(int index) const {
  return _impl_.arguments_.Get(index);
}
inline const std::string& Dynamic_Battery::arguments(int index) const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.arguments)
  return _internal_arguments(index);
}
inline std::string* Dynamic_Battery::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bosproto.Dynamic_Battery.arguments)
  return _impl_.arguments_.Mutable(index);
}
inline void Dynamic_Battery::set_arguments(int index, const std::string& value) {
  _impl_.arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.arguments)
}
inline void Dynamic_Battery::set_arguments(int index, std::string&& value) {
  _impl_.arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.arguments)
}
inline void Dynamic_Battery::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosproto.Dynamic_Battery.arguments)
}
inline void Dynamic_Battery::set_arguments(int index, const char* value, size_t size) {
  _impl_.arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosproto.Dynamic_Battery.arguments)
}
inline std::string* Dynamic_Battery::_internal_add_arguments() {
  return _impl_.arguments_.Add();
}
inline void Dynamic_Battery::add_arguments(const std::string& value) {
  _impl_.arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosproto.Dynamic_Battery.arguments)
}
inline void Dynamic_Battery::add_arguments(std::string&& value) {
  _impl_.arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosproto.Dynamic_Battery.arguments)
}
inline void Dynamic_Battery::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosproto.Dynamic_Battery.arguments)
}
inline void Dynamic_Battery::add_arguments(const char* value, size_t size) {
  _impl_.arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosproto.Dynamic_Battery.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Dynamic_Battery::arguments() const {
  // @@protoc_insertion_point(field_list:bosproto.Dynamic_Battery.arguments)
  return _impl_.arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Dynamic_Battery::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bosproto.Dynamic_Battery.arguments)
  return &_impl_.arguments_;
}

// optional uint64 max_staleness = 7;
inline bool Dynamic_Battery::_internal_has_max_staleness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Dynamic_Battery::has_max_staleness() const {
  return _internal_has_max_staleness();
}
inline void Dynamic_Battery::clear_max_staleness() {
  _impl_.max_staleness_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Dynamic_Battery::_internal_max_staleness() const {
  return _impl_.max_staleness_;
}
inline uint64_t Dynamic_Battery::max_staleness() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.max_staleness)
  return _internal_max_staleness();
}
inline void Dynamic_Battery::_internal_set_max_staleness(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_staleness_ = value;
}
inline void Dynamic_Battery::set_max_staleness(uint64_t value) {
  _internal_set_max_staleness(value);
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.max_staleness)
}

// optional .bosproto.Refresh refresh_mode = 8;
inline bool Dynamic_Battery::_internal_has_refresh_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Dynamic_Battery::has_refresh_mode() const {
  return _internal_has_refresh_mode();
}
inline void Dynamic_Battery::clear_refresh_mode() {
  _impl_.refresh_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::bosproto::Refresh Dynamic_Battery::_internal_refresh_mode() const {
  return static_cast< ::bosproto::Refresh >(_impl_.refresh_mode_);
}
inline ::bosproto::Refresh Dynamic_Battery::refresh_mode() const {
  // @@protoc_insertion_point(field_get:bosproto.Dynamic_Battery.refresh_mode)
  return _internal_refresh_mode();
}
inline void Dynamic_Battery::_internal_set_refresh_mode(::bosproto::Refresh value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.refresh_mode_ = value;
}
inline void Dynamic_Battery::set_refresh_mode(::bosproto::Refresh value) {
  _internal_set_refresh_mode(value);
  // @@protoc_insertion_point(field_set:bosproto.Dynamic_Battery.refresh_mode)
}

// -------------------------------------------------------------------

// Aggregate_Battery

// string batteryName = 1;
inline void Aggregate_Battery::clear_batteryname() {
  _impl_.batteryname_.ClearToEmpty();
}
inline const std::string& Aggregate_Battery::batteryname() const {
  // @@protoc_insertion_point(field_get:bosproto.Aggregate_Battery.batteryName)
  return _internal_batteryname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aggregate_Battery::set_batteryname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batteryname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Aggregate_Battery.batteryName)
}
inline std::string* Aggregate_Battery::mutable_batteryname() {
  std::string* _s = _internal_mutable_batteryname();
  // @@protoc_insertion_point(field_mutable:bosproto.Aggregate_Battery.batteryName)
  return _s;
}
inline const std::string& Aggregate_Battery::_internal_batteryname() const {
  return _impl_.batteryname_.Get();
}
inline void Aggregate_Battery::_internal_set_batteryname(const std::string& value) {
  
  _impl_.batteryname_.Set(value, GetArenaForAllocation());
}
inline std::string* Aggregate_Battery::_internal_mutable_batteryname() {
  
  return _impl_.batteryname_.Mutable(GetArenaForAllocation());
}
inline std::string* Aggregate_Battery::release_batteryname() {
  // @@protoc_insertion_point(field_release:bosproto.Aggregate_Battery.batteryName)
  return _impl_.batteryname_.Release();
}
inline void Aggregate_Battery::set_allocated_batteryname(std::string* batteryname) {
  if (batteryname != nullptr) {
    
  } else {
    
  }
  _impl_.batteryname_.SetAllocated(batteryname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batteryname_.IsDefault()) {
    _impl_.batteryname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Aggregate_Battery.batteryName)
}

// repeated string parentNames = 2;
inline int Aggregate_Battery::_internal_parentnames_size() const {
  return _impl_.parentnames_.size();
}
inline int Aggregate_Battery::parentnames_size() const {
  return _internal_parentnames_size();
}
inline void Aggregate_Battery::clear_parentnames() {
  _impl_.parentnames_.Clear();
}
inline std::string* Aggregate_Battery::add_parentnames() {
  std::string* _s = _internal_add_parentnames();
  // @@protoc_insertion_point(field_add_mutable:bosproto.Aggregate_Battery.parentNames)
  return _s;
}
inline const std::string& Aggregate_Battery::_internal_parentnames(int index) const {
  return _impl_.parentnames_.Get(index);
}
inline const std::string& Aggregate_Battery::parentnames(int index) const {
  // @@protoc_insertion_point(field_get:bosproto.Aggregate_Battery.parentNames)
  return _internal_parentnames(index);
}
inline std::string* Aggregate_Battery::mutable_parentnames(int index) {
  // @@protoc_insertion_point(field_mutable:bosproto.Aggregate_Battery.parentNames)
  return _impl_.parentnames_.Mutable(index);
}
inline void Aggregate_Battery::set_parentnames(int index, const std::string& value) {
  _impl_.parentnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosproto.Aggregate_Battery.parentNames)
}
inline void Aggregate_Battery::set_parentnames(int index, std::string&& value) {
  _impl_.parentnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosproto.Aggregate_Battery.parentNames)
}
inline void Aggregate_Battery::set_parentnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.parentnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosproto.Aggregate_Battery.parentNames)
}
inline void Aggregate_Battery::set_parentnames(int index, const char* value, size_t size) {
  _impl_.parentnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosproto.Aggregate_Battery.parentNames)
}
inline std::string* Aggregate_Battery::_internal_add_parentnames() {
  return _impl_.parentnames_.Add();
}
inline void Aggregate_Battery::add_parentnames(const std::string& value) {
  _impl_.parentnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosproto.Aggregate_Battery.parentNames)
}
inline void Aggregate_Battery::add_parentnames(std::string&& value) {
  _impl_.parentnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosproto.Aggregate_Battery.parentNames)
}
inline void Aggregate_Battery::add_parentnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.parentnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosproto.Aggregate_Battery.parentNames)
}
inline void Aggregate_Battery::add_parentnames(const char* value, size_t size) {
  _impl_.parentnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosproto.Aggregate_Battery.parentNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Aggregate_Battery::parentnames() const {
  // @@protoc_insertion_point(field_list:bosproto.Aggregate_Battery.parentNames)
  return _impl_.parentnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Aggregate_Battery::mutable_parentnames() {
  // @@protoc_insertion_point(field_mutable_list:bosproto.Aggregate_Battery.parentNames)
  return &_impl_.parentnames_;
}

// optional uint64 max_staleness = 3;
inline bool Aggregate_Battery::_internal_has_max_staleness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Aggregate_Battery::has_max_staleness() const {
  return _internal_has_max_staleness();
}
inline void Aggregate_Battery::clear_max_staleness() {
  _impl_.max_staleness_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Aggregate_Battery::_internal_max_staleness() const {
  return _impl_.max_staleness_;
}
inline uint64_t Aggregate_Battery::max_staleness() const {
  // @@protoc_insertion_point(field_get:bosproto.Aggregate_Battery.max_staleness)
  return _internal_max_staleness();
}
inline void Aggregate_Battery::_internal_set_max_staleness(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_staleness_ = value;
}
inline void Aggregate_Battery::set_max_staleness(uint64_t value) {
  _internal_set_max_staleness(value);
  // @@protoc_insertion_point(field_set:bosproto.Aggregate_Battery.max_staleness)
}

// optional .bosproto.Refresh refresh_mode = 4;
inline bool Aggregate_Battery::_internal_has_refresh_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Aggregate_Battery::has_refresh_mode() const {
  return _internal_has_refresh_mode();
}
inline void Aggregate_Battery::clear_refresh_mode() {
  _impl_.refresh_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::bosproto::Refresh Aggregate_Battery::_internal_refresh_mode() const {
  return static_cast< ::bosproto::Refresh >(_impl_.refresh_mode_);
}
inline ::bosproto::Refresh Aggregate_Battery::refresh_mode() const {
  // @@protoc_insertion_point(field_get:bosproto.Aggregate_Battery.refresh_mode)
  return _internal_refresh_mode();
}
inline void Aggregate_Battery::_internal_set_refresh_mode(::bosproto::Refresh value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.refresh_mode_ = value;
}
inline void Aggregate_Battery::set_refresh_mode(::bosproto::Refresh value) {
  _internal_set_refresh_mode(value);
  // @@protoc_insertion_point(field_set:bosproto.Aggregate_Battery.refresh_mode)
}

// -------------------------------------------------------------------

// Partition_Battery

// string sourceName = 1;
inline void Partition_Battery::clear_sourcename() {
  _impl_.sourcename_.ClearToEmpty();
}
inline const std::string& Partition_Battery::sourcename() const {
  // @@protoc_insertion_point(field_get:bosproto.Partition_Battery.sourceName)
  return _internal_sourcename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Partition_Battery::set_sourcename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sourcename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.Partition_Battery.sourceName)
}
inline std::string* Partition_Battery::mutable_sourcename() {
  std::string* _s = _internal_mutable_sourcename();
  // @@protoc_insertion_point(field_mutable:bosproto.Partition_Battery.sourceName)
  return _s;
}
inline const std::string& Partition_Battery::_internal_sourcename() const {
  return _impl_.sourcename_.Get();
}
inline void Partition_Battery::_internal_set_sourcename(const std::string& value) {
  
  _impl_.sourcename_.Set(value, GetArenaForAllocation());
}
inline std::string* Partition_Battery::_internal_mutable_sourcename() {
  
  return _impl_.sourcename_.Mutable(GetArenaForAllocation());
}
inline std::string* Partition_Battery::release_sourcename() {
  // @@protoc_insertion_point(field_release:bosproto.Partition_Battery.sourceName)
  return _impl_.sourcename_.Release();
}
inline void Partition_Battery::set_allocated_sourcename(std::string* sourcename) {
  if (sourcename != nullptr) {
    
  } else {
    
  }
  _impl_.sourcename_.SetAllocated(sourcename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcename_.IsDefault()) {
    _impl_.sourcename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bosproto.Partition_Battery.sourceName)
}

// .bosproto.Policy policy = 2;
inline void Partition_Battery::clear_policy() {
  _impl_.policy_ = 0;
}
inline ::bosproto::Policy Partition_Battery::_internal_policy() const {
  return static_cast< ::bosproto::Policy >(_impl_.policy_);
}
inline ::bosproto::Policy Partition_Battery::policy() const {
  // @@protoc_insertion_point(field_get:bosproto.Partition_Battery.policy)
  return _internal_policy();
}
inline void Partition_Battery::_internal_set_policy(::bosproto::Policy value) {
  
  _impl_.policy_ = value;
}
inline void Partition_Battery::set_policy(::bosproto::Policy value) {
  _internal_set_policy(value);
  // @@protoc_insertion_point(field_set:bosproto.Partition_Battery.policy)
}

// repeated string names = 3;
inline int Partition_Battery::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int Partition_Battery::names_size() const {
  return _internal_names_size();
}
inline void Partition_Battery::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* Partition_Battery::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:bosproto.Partition_Battery.names)
  return _s;
}
inline const std::string& Partition_Battery::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& Partition_Battery::names(int index) const {
  // @@protoc_insertion_point(field_get:bosproto.Partition_Battery.names)
  return _internal_names(index);
}
inline std::string* Partition_Battery::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:bosproto.Partition_Battery.names)
  return _impl_.names_.Mutable(index);
}
inline void Partition_Battery::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bosproto.Partition_Battery.names)
}
inline void Partition_Battery::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bosproto.Partition_Battery.names)
}
inline void Partition_Battery::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosproto.Partition_Battery.names)
}
inline void Partition_Battery::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosproto.Partition_Battery.names)
}
inline std::string* Partition_Battery::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void Partition_Battery::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosproto.Partition_Battery.names)
}
inline void Partition_Battery::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosproto.Partition_Battery.names)
}
inline void Partition_Battery::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosproto.Partition_Battery.names)
}
inline void Partition_Battery::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosproto.Partition_Battery.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Partition_Battery::names() const {
  // @@protoc_insertion_point(field_list:bosproto.Partition_Battery.names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Partition_Battery::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:bosproto.Partition_Battery.names)
  return &_impl_.names_;
}

// repeated .bosproto.Scale scales = 4;
inline int Partition_Battery::_internal_scales_size() const {
  return _impl_.scales_.size();
}
inline int Partition_Battery::scales_size() const {
  return _internal_scales_size();
}
inline void Partition_Battery::clear_scales() {
  _impl_.scales_.Clear();
}
inline ::bosproto::Scale* Partition_Battery::mutable_scales(int index) {
  // @@protoc_insertion_point(field_mutable:bosproto.Partition_Battery.scales)
  return _impl_.scales_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosproto::Scale >*
Partition_Battery::mutable_scales() {
  // @@protoc_insertion_point(field_mutable_list:bosproto.Partition_Battery.scales)
  return &_impl_.scales_;
}
inline const ::bosproto::Scale& Partition_Battery::_internal_scales(int index) const {
  return _impl_.scales_.Get(index);
}
inline const ::bosproto::Scale& Partition_Battery::scales(int index) const {
  // @@protoc_insertion_point(field_get:bosproto.Partition_Battery.scales)
  return _internal_scales(index);
}
inline ::bosproto::Scale* Partition_Battery::_internal_add_scales() {
  return _impl_.scales_.Add();
}
inline ::bosproto::Scale* Partition_Battery::add_scales() {
  ::bosproto::Scale* _add = _internal_add_scales();
  // @@protoc_insertion_point(field_add:bosproto.Partition_Battery.scales)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosproto::Scale >&
Partition_Battery::scales() const {
  // @@protoc_insertion_point(field_list:bosproto.Partition_Battery.scales)
  return _impl_.scales_;
}

// repeated uint64 max_stalenesses = 5;
inline int Partition_Battery::_internal_max_stalenesses_size() const {
  return _impl_.max_stalenesses_.size();
}
inline int Partition_Battery::max_stalenesses_size() const {
  return _internal_max_stalenesses_size();
}
inline void Partition_Battery::clear_max_stalenesses() {
  _impl_.max_stalenesses_.Clear();
}
inline uint64_t Partition_Battery::_internal_max_stalenesses(int index) const {
  return _impl_.max_stalenesses_.Get(index);
}
inline uint64_t Partition_Battery::max_stalenesses(int index) const {
  // @@protoc_insertion_point(field_get:bosproto.Partition_Battery.max_stalenesses)
  return _internal_max_stalenesses(index);
}
inline void Partition_Battery::set_max_stalenesses(int index, uint64_t value) {
  _impl_.max_stalenesses_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosproto.Partition_Battery.max_stalenesses)
}
inline void Partition_Battery::_internal_add_max_stalenesses(uint64_t value) {
  _impl_.max_stalenesses_.Add(value);
}
inline void Partition_Battery::add_max_stalenesses(uint64_t value) {
  _internal_add_max_stalenesses(value);
  // @@protoc_insertion_point(field_add:bosproto.Partition_Battery.max_stalenesses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Partition_Battery::_internal_max_stalenesses() const {
  return _impl_.max_stalenesses_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Partition_Battery::max_stalenesses() const {
  // @@protoc_insertion_point(field_list:bosproto.Partition_Battery.max_stalenesses)
  return _internal_max_stalenesses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Partition_Battery::_internal_mutable_max_stalenesses() {
  return &_impl_.max_stalenesses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Partition_Battery::mutable_max_stalenesses() {
  // @@protoc_insertion_point(field_mutable_list:bosproto.Partition_Battery.max_stalenesses)
  return _internal_mutable_max_stalenesses();
}

// repeated .bosproto.Refresh refresh_modes = 6;
inline int Partition_Battery::_internal_refresh_modes_size() const {
  return _impl_.refresh_modes_.size();
}
inline int Partition_Battery::refresh_modes_size() const {
  return _internal_refresh_modes_size();
}
inline void Partition_Battery::clear_refresh_modes() {
  _impl_.refresh_modes_.Clear();
}
inline ::bosproto::Refresh Partition_Battery::_internal_refresh_modes(int index) const {
  return static_cast< ::bosproto::Refresh >(_impl_.refresh_modes_.Get(index));
}
inline ::bosproto::Refresh Partition_Battery::refresh_modes(int index) const {
  // @@protoc_insertion_point(field_get:bosproto.Partition_Battery.refresh_modes)
  return _internal_refresh_modes(index);
}
inline void Partition_Battery::set_refresh_modes(int index, ::bosproto::Refresh value) {
  _impl_.refresh_modes_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosproto.Partition_Battery.refresh_modes)
}
inline void Partition_Battery::_internal_add_refresh_modes(::bosproto::Refresh value) {
  _impl_.refresh_modes_.Add(value);
}
inline void Partition_Battery::add_refresh_modes(::bosproto::Refresh value) {
  _internal_add_refresh_modes(value);
  // @@protoc_insertion_point(field_add:bosproto.Partition_Battery.refresh_modes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Partition_Battery::refresh_modes() const {
  // @@protoc_insertion_point(field_list:bosproto.Partition_Battery.refresh_modes)
  return _impl_.refresh_modes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Partition_Battery::_internal_mutable_refresh_modes() {
  return &_impl_.refresh_modes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Partition_Battery::mutable_refresh_modes() {
  // @@protoc_insertion_point(field_mutable_list:bosproto.Partition_Battery.refresh_modes)
  return _internal_mutable_refresh_modes();
}

// -------------------------------------------------------------------

// Admin_Command

// .bosproto.Command_Options command_options = 1;
inline void Admin_Command::clear_command_options() {
  _impl_.command_options_ = 0;
}
inline ::bosproto::Command_Options Admin_Command::_internal_command_options() const {
  return static_cast< ::bosproto::Command_Options >(_impl_.command_options_);
}
inline ::bosproto::Command_Options Admin_Command::command_options() const {
  // @@protoc_insertion_point(field_get:bosproto.Admin_Command.command_options)
  return _internal_command_options();
}
inline void Admin_Command::_internal_set_command_options(::bosproto::Command_Options value) {
  
  _impl_.command_options_ = value;
}
inline void Admin_Command::set_command_options(::bosproto::Command_Options value) {
  _internal_set_command_options(value);
  // @@protoc_insertion_point(field_set:bosproto.Admin_Command.command_options)
}

// .bosproto.Physical_Battery physical_battery = 2;
inline bool Admin_Command::_internal_has_physical_battery() const {
  return command_parameters_case() == kPhysicalBattery;
}
inline bool Admin_Command::has_physical_battery() const {
  return _internal_has_physical_battery();
}
inline void Admin_Command::set_has_physical_battery() {
  _impl_._oneof_case_[0] = kPhysicalBattery;
}
inline void Admin_Command::clear_physical_battery() {
  if (_internal_has_physical_battery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_parameters_.physical_battery_;
    }
    clear_has_command_parameters();
  }
}
inline ::bosproto::Physical_Battery* Admin_Command::release_physical_battery() {
  // @@protoc_insertion_point(field_release:bosproto.Admin_Command.physical_battery)
  if (_internal_has_physical_battery()) {
    clear_has_command_parameters();
    ::bosproto::Physical_Battery* temp = _impl_.command_parameters_.physical_battery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_parameters_.physical_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosproto::Physical_Battery& Admin_Command::_internal_physical_battery() const {
  return _internal_has_physical_battery()
      ? *_impl_.command_parameters_.physical_battery_
      : reinterpret_cast< ::bosproto::Physical_Battery&>(::bosproto::_Physical_Battery_default_instance_);
}
inline const ::bosproto::Physical_Battery& Admin_Command::physical_battery() const {
  // @@protoc_insertion_point(field_get:bosproto.Admin_Command.physical_battery)
  return _internal_physical_battery();
}
inline ::bosproto::Physical_Battery* Admin_Command::unsafe_arena_release_physical_battery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosproto.Admin_Command.physical_battery)
  if (_internal_has_physical_battery()) {
    clear_has_command_parameters();
    ::bosproto::Physical_Battery* temp = _impl_.command_parameters_.physical_battery_;
    _impl_.command_parameters_.physical_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Admin_Command::unsafe_arena_set_allocated_physical_battery(::bosproto::Physical_Battery* physical_battery) {
  clear_command_parameters();
  if (physical_battery) {
    set_has_physical_battery();
    _impl_.command_parameters_.physical_battery_ = physical_battery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosproto.Admin_Command.physical_battery)
}
inline ::bosproto::Physical_Battery* Admin_Command::_internal_mutable_physical_battery() {
  if (!_internal_has_physical_battery()) {
    clear_command_parameters();
    set_has_physical_battery();
    _impl_.command_parameters_.physical_battery_ = CreateMaybeMessage< ::bosproto::Physical_Battery >(GetArenaForAllocation());
  }
  return _impl_.command_parameters_.physical_battery_;
}
inline ::bosproto::Physical_Battery* Admin_Command::mutable_physical_battery() {
  ::bosproto::Physical_Battery* _msg = _internal_mutable_physical_battery();
  // @@protoc_insertion_point(field_mutable:bosproto.Admin_Command.physical_battery)
  return _msg;
}

// .bosproto.Aggregate_Battery aggregate_battery = 3;
inline bool Admin_Command::_internal_has_aggregate_battery() const {
  return command_parameters_case() == kAggregateBattery;
}
inline bool Admin_Command::has_aggregate_battery() const {
  return _internal_has_aggregate_battery();
}
inline void Admin_Command::set_has_aggregate_battery() {
  _impl_._oneof_case_[0] = kAggregateBattery;
}
inline void Admin_Command::clear_aggregate_battery() {
  if (_internal_has_aggregate_battery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_parameters_.aggregate_battery_;
    }
    clear_has_command_parameters();
  }
}
inline ::bosproto::Aggregate_Battery* Admin_Command::release_aggregate_battery() {
  // @@protoc_insertion_point(field_release:bosproto.Admin_Command.aggregate_battery)
  if (_internal_has_aggregate_battery()) {
    clear_has_command_parameters();
    ::bosproto::Aggregate_Battery* temp = _impl_.command_parameters_.aggregate_battery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_parameters_.aggregate_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosproto::Aggregate_Battery& Admin_Command::_internal_aggregate_battery() const {
  return _internal_has_aggregate_battery()
      ? *_impl_.command_parameters_.aggregate_battery_
      : reinterpret_cast< ::bosproto::Aggregate_Battery&>(::bosproto::_Aggregate_Battery_default_instance_);
}
inline const ::bosproto::Aggregate_Battery& Admin_Command::aggregate_battery() const {
  // @@protoc_insertion_point(field_get:bosproto.Admin_Command.aggregate_battery)
  return _internal_aggregate_battery();
}
inline ::bosproto::Aggregate_Battery* Admin_Command::unsafe_arena_release_aggregate_battery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosproto.Admin_Command.aggregate_battery)
  if (_internal_has_aggregate_battery()) {
    clear_has_command_parameters();
    ::bosproto::Aggregate_Battery* temp = _impl_.command_parameters_.aggregate_battery_;
    _impl_.command_parameters_.aggregate_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Admin_Command::unsafe_arena_set_allocated_aggregate_battery(::bosproto::Aggregate_Battery* aggregate_battery) {
  clear_command_parameters();
  if (aggregate_battery) {
    set_has_aggregate_battery();
    _impl_.command_parameters_.aggregate_battery_ = aggregate_battery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosproto.Admin_Command.aggregate_battery)
}
inline ::bosproto::Aggregate_Battery* Admin_Command::_internal_mutable_aggregate_battery() {
  if (!_internal_has_aggregate_battery()) {
    clear_command_parameters();
    set_has_aggregate_battery();
    _impl_.command_parameters_.aggregate_battery_ = CreateMaybeMessage< ::bosproto::Aggregate_Battery >(GetArenaForAllocation());
  }
  return _impl_.command_parameters_.aggregate_battery_;
}
inline ::bosproto::Aggregate_Battery* Admin_Command::mutable_aggregate_battery() {
  ::bosproto::Aggregate_Battery* _msg = _internal_mutable_aggregate_battery();
  // @@protoc_insertion_point(field_mutable:bosproto.Admin_Command.aggregate_battery)
  return _msg;
}

// .bosproto.Partition_Battery partition_battery = 4;
inline bool Admin_Command::_internal_has_partition_battery() const {
  return command_parameters_case() == kPartitionBattery;
}
inline bool Admin_Command::has_partition_battery() const {
  return _internal_has_partition_battery();
}
inline void Admin_Command::set_has_partition_battery() {
  _impl_._oneof_case_[0] = kPartitionBattery;
}
inline void Admin_Command::clear_partition_battery() {
  if (_internal_has_partition_battery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_parameters_.partition_battery_;
    }
    clear_has_command_parameters();
  }
}
inline ::bosproto::Partition_Battery* Admin_Command::release_partition_battery() {
  // @@protoc_insertion_point(field_release:bosproto.Admin_Command.partition_battery)
  if (_internal_has_partition_battery()) {
    clear_has_command_parameters();
    ::bosproto::Partition_Battery* temp = _impl_.command_parameters_.partition_battery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_parameters_.partition_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosproto::Partition_Battery& Admin_Command::_internal_partition_battery() const {
  return _internal_has_partition_battery()
      ? *_impl_.command_parameters_.partition_battery_
      : reinterpret_cast< ::bosproto::Partition_Battery&>(::bosproto::_Partition_Battery_default_instance_);
}
inline const ::bosproto::Partition_Battery& Admin_Command::partition_battery() const {
  // @@protoc_insertion_point(field_get:bosproto.Admin_Command.partition_battery)
  return _internal_partition_battery();
}
inline ::bosproto::Partition_Battery* Admin_Command::unsafe_arena_release_partition_battery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosproto.Admin_Command.partition_battery)
  if (_internal_has_partition_battery()) {
    clear_has_command_parameters();
    ::bosproto::Partition_Battery* temp = _impl_.command_parameters_.partition_battery_;
    _impl_.command_parameters_.partition_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Admin_Command::unsafe_arena_set_allocated_partition_battery(::bosproto::Partition_Battery* partition_battery) {
  clear_command_parameters();
  if (partition_battery) {
    set_has_partition_battery();
    _impl_.command_parameters_.partition_battery_ = partition_battery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosproto.Admin_Command.partition_battery)
}
inline ::bosproto::Partition_Battery* Admin_Command::_internal_mutable_partition_battery() {
  if (!_internal_has_partition_battery()) {
    clear_command_parameters();
    set_has_partition_battery();
    _impl_.command_parameters_.partition_battery_ = CreateMaybeMessage< ::bosproto::Partition_Battery >(GetArenaForAllocation());
  }
  return _impl_.command_parameters_.partition_battery_;
}
inline ::bosproto::Partition_Battery* Admin_Command::mutable_partition_battery() {
  ::bosproto::Partition_Battery* _msg = _internal_mutable_partition_battery();
  // @@protoc_insertion_point(field_mutable:bosproto.Admin_Command.partition_battery)
  return _msg;
}

// .bosproto.Dynamic_Battery dynamic_battery = 5;
inline bool Admin_Command::_internal_has_dynamic_battery() const {
  return command_parameters_case() == kDynamicBattery;
}
inline bool Admin_Command::has_dynamic_battery() const {
  return _internal_has_dynamic_battery();
}
inline void Admin_Command::set_has_dynamic_battery() {
  _impl_._oneof_case_[0] = kDynamicBattery;
}
inline void Admin_Command::clear_dynamic_battery() {
  if (_internal_has_dynamic_battery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_parameters_.dynamic_battery_;
    }
    clear_has_command_parameters();
  }
}
inline ::bosproto::Dynamic_Battery* Admin_Command::release_dynamic_battery() {
  // @@protoc_insertion_point(field_release:bosproto.Admin_Command.dynamic_battery)
  if (_internal_has_dynamic_battery()) {
    clear_has_command_parameters();
    ::bosproto::Dynamic_Battery* temp = _impl_.command_parameters_.dynamic_battery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_parameters_.dynamic_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosproto::Dynamic_Battery& Admin_Command::_internal_dynamic_battery() const {
  return _internal_has_dynamic_battery()
      ? *_impl_.command_parameters_.dynamic_battery_
      : reinterpret_cast< ::bosproto::Dynamic_Battery&>(::bosproto::_Dynamic_Battery_default_instance_);
}
inline const ::bosproto::Dynamic_Battery& Admin_Command::dynamic_battery() const {
  // @@protoc_insertion_point(field_get:bosproto.Admin_Command.dynamic_battery)
  return _internal_dynamic_battery();
}
inline ::bosproto::Dynamic_Battery* Admin_Command::unsafe_arena_release_dynamic_battery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosproto.Admin_Command.dynamic_battery)
  if (_internal_has_dynamic_battery()) {
    clear_has_command_parameters();
    ::bosproto::Dynamic_Battery* temp = _impl_.command_parameters_.dynamic_battery_;
    _impl_.command_parameters_.dynamic_battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Admin_Command::unsafe_arena_set_allocated_dynamic_battery(::bosproto::Dynamic_Battery* dynamic_battery) {
  clear_command_parameters();
  if (dynamic_battery) {
    set_has_dynamic_battery();
    _impl_.command_parameters_.dynamic_battery_ = dynamic_battery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosproto.Admin_Command.dynamic_battery)
}
inline ::bosproto::Dynamic_Battery* Admin_Command::_internal_mutable_dynamic_battery() {
  if (!_internal_has_dynamic_battery()) {
    clear_command_parameters();
    set_has_dynamic_battery();
    _impl_.command_parameters_.dynamic_battery_ = CreateMaybeMessage< ::bosproto::Dynamic_Battery >(GetArenaForAllocation());
  }
  return _impl_.command_parameters_.dynamic_battery_;
}
inline ::bosproto::Dynamic_Battery* Admin_Command::mutable_dynamic_battery() {
  ::bosproto::Dynamic_Battery* _msg = _internal_mutable_dynamic_battery();
  // @@protoc_insertion_point(field_mutable:bosproto.Admin_Command.dynamic_battery)
  return _msg;
}

inline bool Admin_Command::has_command_parameters() const {
  return command_parameters_case() != COMMAND_PARAMETERS_NOT_SET;
}
inline void Admin_Command::clear_has_command_parameters() {
  _impl_._oneof_case_[0] = COMMAND_PARAMETERS_NOT_SET;
}
inline Admin_Command::CommandParametersCase Admin_Command::command_parameters_case() const {
  return Admin_Command::CommandParametersCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AdminResponse

// int64 return_code = 1;
inline void AdminResponse::clear_return_code() {
  _impl_.return_code_ = int64_t{0};
}
inline int64_t AdminResponse::_internal_return_code() const {
  return _impl_.return_code_;
}
inline int64_t AdminResponse::return_code() const {
  // @@protoc_insertion_point(field_get:bosproto.AdminResponse.return_code)
  return _internal_return_code();
}
inline void AdminResponse::_internal_set_return_code(int64_t value) {
  
  _impl_.return_code_ = value;
}
inline void AdminResponse::set_return_code(int64_t value) {
  _internal_set_return_code(value);
  // @@protoc_insertion_point(field_set:bosproto.AdminResponse.return_code)
}

// string success_message = 2;
inline bool AdminResponse::_internal_has_success_message() const {
  return return_value_case() == kSuccessMessage;
}
inline bool AdminResponse::has_success_message() const {
  return _internal_has_success_message();
}
inline void AdminResponse::set_has_success_message() {
  _impl_._oneof_case_[0] = kSuccessMessage;
}
inline void AdminResponse::clear_success_message() {
  if (_internal_has_success_message()) {
    _impl_.return_value_.success_message_.Destroy();
    clear_has_return_value();
  }
}
inline const std::string& AdminResponse::success_message() const {
  // @@protoc_insertion_point(field_get:bosproto.AdminResponse.success_message)
  return _internal_success_message();
}
template <typename ArgT0, typename... ArgT>
inline void AdminResponse::set_success_message(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_success_message()) {
    clear_return_value();
    set_has_success_message();
    _impl_.return_value_.success_message_.InitDefault();
  }
  _impl_.return_value_.success_message_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.AdminResponse.success_message)
}
inline std::string* AdminResponse::mutable_success_message() {
  std::string* _s = _internal_mutable_success_message();
  // @@protoc_insertion_point(field_mutable:bosproto.AdminResponse.success_message)
  return _s;
}
inline const std::string& AdminResponse::_internal_success_message() const {
  if (_internal_has_success_message()) {
    return _impl_.return_value_.success_message_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminResponse::_internal_set_success_message(const std::string& value) {
  if (!_internal_has_success_message()) {
    clear_return_value();
    set_has_success_message();
    _impl_.return_value_.success_message_.InitDefault();
  }
  _impl_.return_value_.success_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminResponse::_internal_mutable_success_message() {
  if (!_internal_has_success_message()) {
    clear_return_value();
    set_has_success_message();
    _impl_.return_value_.success_message_.InitDefault();
  }
  return _impl_.return_value_.success_message_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminResponse::release_success_message() {
  // @@protoc_insertion_point(field_release:bosproto.AdminResponse.success_message)
  if (_internal_has_success_message()) {
    clear_has_return_value();
    return _impl_.return_value_.success_message_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminResponse::set_allocated_success_message(std::string* success_message) {
  if (has_return_value()) {
    clear_return_value();
  }
  if (success_message != nullptr) {
    set_has_success_message();
    _impl_.return_value_.success_message_.InitAllocated(success_message, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:bosproto.AdminResponse.success_message)
}

// string failure_message = 3;
inline bool AdminResponse::_internal_has_failure_message() const {
  return return_value_case() == kFailureMessage;
}
inline bool AdminResponse::has_failure_message() const {
  return _internal_has_failure_message();
}
inline void AdminResponse::set_has_failure_message() {
  _impl_._oneof_case_[0] = kFailureMessage;
}
inline void AdminResponse::clear_failure_message() {
  if (_internal_has_failure_message()) {
    _impl_.return_value_.failure_message_.Destroy();
    clear_has_return_value();
  }
}
inline const std::string& AdminResponse::failure_message() const {
  // @@protoc_insertion_point(field_get:bosproto.AdminResponse.failure_message)
  return _internal_failure_message();
}
template <typename ArgT0, typename... ArgT>
inline void AdminResponse::set_failure_message(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_failure_message()) {
    clear_return_value();
    set_has_failure_message();
    _impl_.return_value_.failure_message_.InitDefault();
  }
  _impl_.return_value_.failure_message_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bosproto.AdminResponse.failure_message)
}
inline std::string* AdminResponse::mutable_failure_message() {
  std::string* _s = _internal_mutable_failure_message();
  // @@protoc_insertion_point(field_mutable:bosproto.AdminResponse.failure_message)
  return _s;
}
inline const std::string& AdminResponse::_internal_failure_message() const {
  if (_internal_has_failure_message()) {
    return _impl_.return_value_.failure_message_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminResponse::_internal_set_failure_message(const std::string& value) {
  if (!_internal_has_failure_message()) {
    clear_return_value();
    set_has_failure_message();
    _impl_.return_value_.failure_message_.InitDefault();
  }
  _impl_.return_value_.failure_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminResponse::_internal_mutable_failure_message() {
  if (!_internal_has_failure_message()) {
    clear_return_value();
    set_has_failure_message();
    _impl_.return_value_.failure_message_.InitDefault();
  }
  return _impl_.return_value_.failure_message_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminResponse::release_failure_message() {
  // @@protoc_insertion_point(field_release:bosproto.AdminResponse.failure_message)
  if (_internal_has_failure_message()) {
    clear_has_return_value();
    return _impl_.return_value_.failure_message_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminResponse::set_allocated_failure_message(std::string* failure_message) {
  if (has_return_value()) {
    clear_return_value();
  }
  if (failure_message != nullptr) {
    set_has_failure_message();
    _impl_.return_value_.failure_message_.InitAllocated(failure_message, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:bosproto.AdminResponse.failure_message)
}

inline bool AdminResponse::has_return_value() const {
  return return_value_case() != RETURN_VALUE_NOT_SET;
}
inline void AdminResponse::clear_has_return_value() {
  _impl_._oneof_case_[0] = RETURN_VALUE_NOT_SET;
}
inline AdminResponse::ReturnValueCase AdminResponse::return_value_case() const {
  return AdminResponse::ReturnValueCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bosproto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosproto::Refresh> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosproto::Refresh>() {
  return ::bosproto::Refresh_descriptor();
}
template <> struct is_proto_enum< ::bosproto::Policy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosproto::Policy>() {
  return ::bosproto::Policy_descriptor();
}
template <> struct is_proto_enum< ::bosproto::Command_Options> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosproto::Command_Options>() {
  return ::bosproto::Command_Options_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_battery_5fmanager_2eproto
